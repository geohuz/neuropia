## **异步更新场景下的数据库设计问题**

### **1. 当前同步设计 vs 异步设计的矛盾**

**同步设计**（你当前的）：
```
扣费 → 更新account_balance → 写audit_log → 写usage_log
   (同一个事务，强一致性)
```

**异步设计**（你考虑的）：

```
扣费 → Redis扣费成功 → 异步写DB
   (实时在Redis，最终一致性到DB)
```

### **2. 关键问题：异步只写usage_log是否可行？**

**不可行，原因如下**：

1. **余额不一致**：`account_balance`表无法反映实时余额
2. **审计断链**：`account_balance_audit`无法追踪每次资金变动
3. **对账困难**：无法验证Redis和DB的数据一致性
4. **统计失真**：基于usage_log的统计可能和实际余额对不上

### **3. 异步更新下的数据库设计方案**

#### **3.1 核心原则：双写但接受延迟**
```
Redis（实时源） → 异步同步 → PostgreSQL（持久化副本）
```

#### **3.2 表结构调整建议**

##### **3.2.1 account_balance表增加异步标记**
```sql
ALTER TABLE data.account_balance 
ADD COLUMN last_sync_time TIMESTAMP,
ADD COLUMN sync_version BIGINT DEFAULT 0,  -- 用于乐观同步
ADD COLUMN redis_balance NUMERIC,  -- 最后一次从Redis同步的余额
ADD COLUMN sync_status VARCHAR(20) DEFAULT 'in_sync';
```

##### **3.2.2 创建异步同步日志表**
```sql
CREATE TABLE data.balance_sync_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    account_id UUID NOT NULL REFERENCES data.account_balance(id),
    tenant_id UUID,
    user_id UUID,
    
    -- Redis源数据
    redis_balance NUMERIC NOT NULL,
    redis_daily_used NUMERIC,
    redis_credit_used NUMERIC,
    redis_timestamp TIMESTAMP NOT NULL,
    
    -- DB目标数据（同步前）
    db_balance_before NUMERIC NOT NULL,
    db_daily_used_before NUMERIC,
    
    -- 同步结果
    sync_result VARCHAR(20) NOT NULL, -- 'success', 'conflict', 'error'
    conflict_resolution VARCHAR(20), -- 'redis_wins', 'db_wins', 'manual'
    resolved_balance NUMERIC,
    
    -- 差异信息
    balance_diff NUMERIC GENERATED ALWAYS AS (redis_balance - db_balance_before) STORED,
    is_balance_match BOOLEAN GENERATED ALWAYS AS (redis_balance = db_balance_before) STORED,
    
    created_at TIMESTAMP DEFAULT NOW(),
    synced_at TIMESTAMP,
    
    INDEX idx_sync_log_account (account_id, created_at DESC),
    INDEX idx_sync_log_unresolved (sync_result) WHERE sync_result = 'conflict'
);
```

##### **3.2.3 usage_log增加同步状态**
```sql
ALTER TABLE data.usage_log 
ADD COLUMN deduction_id VARCHAR(100) UNIQUE,  -- Redis中的扣费ID
ADD COLUMN redis_sync_time TIMESTAMP,  -- 何时从Redis同步
ADD COLUMN sync_status VARCHAR(20) DEFAULT 'pending',
ADD COLUMN sync_attempts INT DEFAULT 0;
```

### **4. 异步更新策略（三阶段）**

#### **4.1 第一阶段：基础异步写入**
```
BillingWorker任务：
1. 从Redis Stream读取批量扣费记录
2. 批量插入usage_log（状态=pending）
3. 批量更新account_balance（累加total_consumed，不更新实时余额）
4. 批量插入account_balance_audit（记录扣费，但不更新余额字段）
```

**注意**：这个阶段account_balance的balance字段不更新，只作为历史记录。

#### **4.2 第二阶段：定期余额同步**
```
每小时运行BalanceSyncWorker：
1. 从Redis获取所有账户的最新余额
2. 批量更新account_balance.redis_balance字段
3. 记录到balance_sync_log表
4. 检查差异，对账报警
```

#### **4.3 第三阶段：最终余额对齐**
```
每日对账任务：
1. 计算：Redis总余额变化量 = ∑扣费金额
2. 计算：DB总余额变化量 = account_balance_audit.amount总和
3. 比对差异，生成修复SQL
4. 人工确认或自动修复
```

### **5. 统计查询的应对策略**

#### **5.1 实时统计 vs 最终统计**
```sql
-- 实时统计（从Redis聚合）
SELECT * FROM redis实时统计API

-- 最终统计（从DB查询，可能延迟）
CREATE MATERIALIZED VIEW data.v_final_account_stats AS
SELECT 
    ab.owner_tenantid,
    ab.owner_userid,
    ab.balance as db_balance,  -- DB余额（可能滞后）
    ab.redis_balance,          -- Redis余额（最后一次同步）
    ab.total_consumed,         -- 历史总消费（准确）
    COALESCE(SUM(ul.cost), 0) as today_cost,
    COUNT(ul.id) as today_requests
FROM data.account_balance ab
LEFT JOIN data.usage_log ul ON (
    DATE(ul.created_at) = CURRENT_DATE AND
    (ul.user_id = ab.owner_userid OR ul.user_id IS NULL)
)
GROUP BY ab.id;

-- 每小时刷新物化视图
```

#### **5.2 混合查询方案**
对于需要实时+准确数据的场景：
```sql
-- 应用层逻辑：
1. 先查Redis获取实时余额
2. 再查DB获取详细交易记录
3. 合并返回给前端
```

### **6. 对账与修复机制**

#### **6.1 每日对账流程**
```
1. 源头对账：Redis扣费总额 vs usage_log总额
2. 余额对账：Redis余额 vs account_balance.redis_balance
3. 流水对账：account_balance_audit总额 vs usage_log总额
4. 生成差异报告，标记异常账户
```

#### **6.2 自动修复策略**
```sql
-- 当差异在可接受范围内（如<0.01美元）
UPDATE data.account_balance 
SET balance = redis_balance,
    last_sync_time = NOW(),
    sync_status = 'auto_fixed'
WHERE ABS(balance - redis_balance) < 0.01;

-- 记录修复操作到audit表
INSERT INTO data.account_balance_audit (...)
VALUES ('AUTO_FIX', 'system', ...);
```

### **7. 关键设计决策点**

#### **7.1 异步更新的程度选择**
**方案A：完全异步（推荐）**
- account_balance.balance字段不实时更新
- 实时余额查询走Redis
- DB只作为持久化归档

**方案B：部分异步**
- 高频扣费异步，大额充值同步
- account_balance.balance延迟更新（如每分钟）
- 复杂度更高

#### **7.2 数据一致性级别**
- **最终一致性**：接受分钟级延迟，最简单
- **会话一致性**：同一用户的查询保持一致
- **强一致性**：关键操作同步写DB

### **8. 推荐的异步架构**

```
实时层（Redis）：
  - 实时余额
  - 扣费队列
  - 实时统计

异步层（BillingWorker）：
  - 批量写usage_log
  - 批量写audit_log（不更新余额）
  - 更新total_consumed

同步层（定期任务）：
  - 每小时同步余额到account_balance.redis_balance
  - 每日对账修复
  - 刷新物化视图

查询层：
  - 实时查询：Redis + usage_log
  - 历史查询：DB汇总表
  - 对账查询：sync_log表
```

### **9. 结论：异步更新不能只写usage_log**

**必须同时维护**：
1. **usage_log**：扣费明细记录
2. **account_balance_audit**：资金变动流水
3. **account_balance**：账户快照（可延迟）
4. **balance_sync_log**：同步日志和对账依据

**核心思想**：接受余额的短暂不一致，但保证所有交易记录不丢失，并提供完整的对账修复机制。



很好！基于异步更新的设计，我们来设计数据库改进方案。我会提供一个系统性的升级方案，保持向后兼容。

## **数据库升级方案（分阶段实施）**

### **阶段一：基础表结构调整（兼容现有系统）**

#### **1.1 改进 account_balance 表**
```sql
-- 1. 清理现有数据问题（确保每个账户单一类型）
UPDATE data.account_balance 
SET owner_userid = NULL 
WHERE owner_tenantid IS NOT NULL 
AND owner_userid IS NOT NULL;

-- 2. 添加异步更新相关字段
ALTER TABLE data.account_balance 
-- 账户类型标识（计算字段）
ADD COLUMN account_type VARCHAR(10) GENERATED ALWAYS AS (
    CASE 
        WHEN owner_userid IS NOT NULL THEN 'user' 
        WHEN owner_tenantid IS NOT NULL THEN 'tenant'
        ELSE 'unknown'
    END
) STORED,

-- 异步同步相关
ADD COLUMN sync_version BIGINT DEFAULT 0,
ADD COLUMN redis_balance NUMERIC,
ADD COLUMN last_redis_sync TIMESTAMP,
ADD COLUMN last_balance_calc TIMESTAMP,

-- 统计字段（累计值，异步更新）
ADD COLUMN total_consumed NUMERIC DEFAULT 0,
ADD COLUMN total_topup NUMERIC DEFAULT 0,
ADD COLUMN total_adjustments NUMERIC DEFAULT 0,

-- 信用相关
ADD COLUMN credit_limit NUMERIC DEFAULT 0,
ADD COLUMN credit_used NUMERIC DEFAULT 0,

-- 状态控制
ADD COLUMN status VARCHAR(20) DEFAULT 'active',
ADD COLUMN freeze_reason TEXT,

-- 乐观锁
ADD COLUMN balance_version BIGINT DEFAULT 0,
ADD COLUMN audit_version BIGINT DEFAULT 0;

-- 3. 添加约束
ALTER TABLE data.account_balance
ADD CONSTRAINT single_owner_check CHECK (
    (owner_userid IS NOT NULL AND owner_tenantid IS NULL) OR
    (owner_userid IS NULL AND owner_tenantid IS NOT NULL)
);

-- 5. 创建索引
CREATE INDEX IF NOT EXISTS idx_account_balance_type_user 
ON data.account_balance(owner_userid) 
WHERE owner_userid IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_account_balance_type_tenant 
ON data.account_balance(owner_tenantid) 
WHERE owner_tenantid IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_account_balance_status 
ON data.account_balance(status) 
WHERE status != 'active';
```

#### **1.2 改进 account_balance_audit 表**
```sql
-- 1. 增加异步同步相关字段
ALTER TABLE data.account_balance_audit 
-- 关联字段
ADD COLUMN usage_log_id UUID REFERENCES data.usage_log(id),
ADD COLUMN deduction_id VARCHAR(100),  -- Redis中的唯一扣费ID
ADD COLUMN reference_id VARCHAR(100),  -- 外部参考ID

-- 审计类型细化
ADD COLUMN audit_category VARCHAR(50),  -- 'usage', 'topup', 'adjustment', 'sync', 'correction'
ADD COLUMN subcategory VARCHAR(50),     -- 更细的分类

-- 同步状态
ADD COLUMN sync_status VARCHAR(20) DEFAULT 'pending',
ADD COLUMN sync_attempts INTEGER DEFAULT 0,
ADD COLUMN last_sync_attempt TIMESTAMP,

-- 差异追踪
ADD COLUMN expected_after_balance NUMERIC,
ADD COLUMN balance_diff NUMERIC,
ADD COLUMN is_balance_match BOOLEAN DEFAULT true,

-- 元数据
ADD COLUMN operation_context JSONB,
ADD COLUMN client_info TEXT;

-- 2. 修改约束
ALTER TABLE data.account_balance_audit
DROP CONSTRAINT IF EXISTS account_balance_audit_account_type_check,
ADD CONSTRAINT audit_account_type_check CHECK (
    account_type IN ('user', 'tenant', 'system')
),
ADD CONSTRAINT audit_category_check CHECK (
    audit_category IN ('usage', 'topup', 'adjustment', 'sync', 'correction', 'fee', 'refund')
);

-- 3. 创建索引
CREATE INDEX IF NOT EXISTS idx_audit_deduction_id 
ON data.account_balance_audit(deduction_id) 
WHERE deduction_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_audit_sync_status 
ON data.account_balance_audit(sync_status, created_at) 
WHERE sync_status != 'completed';

CREATE INDEX IF NOT EXISTS idx_audit_reference 
ON data.account_balance_audit(reference_id) 
WHERE reference_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_audit_usage_log 
ON data.account_balance_audit(usage_log_id) 
WHERE usage_log_id IS NOT NULL;
```

#### **1.3 改进 usage_log 表**
```sql
-- 1. 增加异步相关字段
ALTER TABLE data.usage_log 
-- 唯一标识（防重放）
ADD COLUMN deduction_id VARCHAR(100) UNIQUE,
ADD COLUMN request_id VARCHAR(100),  -- API请求ID

-- 成本细分
ADD COLUMN input_cost NUMERIC,
ADD COLUMN output_cost NUMERIC,
ADD COLUMN base_cost NUMERIC,
ADD COLUMN extra_fee NUMERIC,

-- 异步状态
ADD COLUMN sync_status VARCHAR(20) DEFAULT 'pending',
ADD COLUMN sync_attempts INTEGER DEFAULT 0,
ADD COLUMN last_sync_attempt TIMESTAMP,

-- 关联字段
ADD COLUMN tenant_id UUID,
ADD COLUMN account_id UUID REFERENCES data.account_balance(id),

-- 性能指标
ADD COLUMN queue_time_ms INTEGER,
ADD COLUMN processing_time_ms INTEGER,

-- 元数据
ADD COLUMN endpoint_path TEXT,
ADD COLUMN user_agent TEXT,
ADD COLUMN client_ip INET;

-- 3. 创建索引
CREATE INDEX IF NOT EXISTS idx_usage_log_deduction 
ON data.usage_log(deduction_id);

CREATE INDEX IF NOT EXISTS idx_usage_log_sync_status 
ON data.usage_log(sync_status, created_at) 
WHERE sync_status != 'completed';

CREATE INDEX IF NOT EXISTS idx_usage_log_tenant_date 
ON data.usage_log(tenant_id, created_at DESC) 
WHERE tenant_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_usage_log_account 
ON data.usage_log(account_id) 
WHERE account_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_usage_log_composite 
ON data.usage_log(user_id, provider, model, created_at DESC);
```

### **阶段二：新增支持表**

#### **2.1 创建余额同步日志表**
```sql
CREATE TABLE data.balance_sync_log (
    -- 主键
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sync_batch_id UUID NOT NULL,  -- 同一批次的同步ID
    
    -- 账户信息
    account_id UUID NOT NULL REFERENCES data.account_balance(id),
    account_type VARCHAR(10) NOT NULL,  -- 'user' or 'tenant'
    owner_id UUID NOT NULL,  -- user_id 或 tenant_id
    
    -- Redis源数据（同步时点）
    redis_balance NUMERIC NOT NULL,
    redis_credit_used NUMERIC DEFAULT 0,
    redis_daily_used NUMERIC DEFAULT 0,
    redis_total_consumed NUMERIC DEFAULT 0,
    redis_timestamp TIMESTAMP NOT NULL,
    
    -- 数据库当前状态（同步前）
    db_balance_before NUMERIC NOT NULL,
    db_total_consumed_before NUMERIC DEFAULT 0,
    db_balance_version_before BIGINT NOT NULL,
    
    -- 同步动作
    sync_action VARCHAR(50) NOT NULL,  -- 'full_sync', 'delta_sync', 'correction'
    sync_reason VARCHAR(100),
    
    -- 同步结果
    sync_status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending, success, conflict, error
    conflict_type VARCHAR(50),  -- 'balance_mismatch', 'version_mismatch', 'data_integrity'
    resolved_action VARCHAR(50),  -- 'redis_wins', 'db_wins', 'merge', 'manual'
    
    -- 解决后的值
    resolved_balance NUMERIC,
    resolved_total_consumed NUMERIC,
    resolved_notes TEXT,
    
    -- 差异信息
    balance_diff NUMERIC GENERATED ALWAYS AS (redis_balance - db_balance_before) STORED,
    consumed_diff NUMERIC GENERATED ALWAYS AS (redis_total_consumed - db_total_consumed_before) STORED,
    diff_percentage NUMERIC GENERATED ALWAYS AS (
        CASE 
            WHEN db_balance_before = 0 THEN NULL
            ELSE ABS((redis_balance - db_balance_before) / db_balance_before)
        END
    ) STORED,
    
    -- 审计信息
    operator_id UUID,  -- 操作人（系统或管理员）
    retry_count INTEGER DEFAULT 0,
    error_message TEXT,
    stack_trace TEXT,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    processed_at TIMESTAMP,
    completed_at TIMESTAMP,
    
    -- 索引
    UNIQUE(account_id, sync_batch_id)
);

-- 索引
CREATE INDEX idx_sync_log_batch ON data.balance_sync_log(sync_batch_id);
CREATE INDEX idx_sync_log_account_date ON data.balance_sync_log(account_id, created_at DESC);
CREATE INDEX idx_sync_log_status ON data.balance_sync_log(sync_status) WHERE sync_status IN ('pending', 'conflict');
CREATE INDEX idx_sync_log_owner ON data.balance_sync_log(owner_id, account_type);
CREATE INDEX idx_sync_log_diff ON data.balance_sync_log(ABS(balance_diff) DESC NULLS LAST);
```

#### **2.2 创建每日统计汇总表**
```sql
CREATE TABLE data.daily_account_summary (
    -- 主键
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 维度
    summary_date DATE NOT NULL,
    account_id UUID NOT NULL REFERENCES data.account_balance(id),
    account_type VARCHAR(10) NOT NULL,
    owner_id UUID NOT NULL,
    
    -- 用量统计
    request_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    fail_count INTEGER DEFAULT 0,
    
    -- Token统计
    total_tokens INTEGER DEFAULT 0,
    total_input_tokens INTEGER DEFAULT 0,
    total_output_tokens INTEGER DEFAULT 0,
    
    -- 成本统计
    total_cost NUMERIC DEFAULT 0,
    input_cost NUMERIC DEFAULT 0,
    output_cost NUMERIC DEFAULT 0,
    extra_fee NUMERIC DEFAULT 0,
    
    -- 性能统计
    avg_latency_ms NUMERIC,
    p95_latency_ms NUMERIC,
    p99_latency_ms NUMERIC,
    
    -- 提供商统计（JSON格式）
    provider_stats JSONB DEFAULT '{}',
    model_stats JSONB DEFAULT '{}',
    
    -- 状态
    calc_status VARCHAR(20) DEFAULT 'pending',  -- pending, processing, completed, error
    calc_version INTEGER DEFAULT 1,
    last_calc_time TIMESTAMP,
    
    -- 审计
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- 约束和索引
    UNIQUE(account_id, summary_date)
);

-- 索引
CREATE INDEX idx_daily_summary_date ON data.daily_account_summary(summary_date DESC);
CREATE INDEX idx_daily_summary_account ON data.daily_account_summary(account_id, summary_date DESC);
CREATE INDEX idx_daily_summary_owner ON data.daily_account_summary(owner_id, summary_date DESC);
CREATE INDEX idx_daily_summary_status ON data.daily_account_summary(calc_status) WHERE calc_status != 'completed';

-- 添加分区支持（如果数据量大）
-- 可以按月份分区：PARTITION BY RANGE (summary_date)
```

#### **2.3 创建对账结果表**
```sql
CREATE TABLE data.reconciliation_report (
    -- 主键
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_date DATE NOT NULL,
    report_type VARCHAR(50) NOT NULL,  -- 'daily', 'weekly', 'monthly', 'ad_hoc'
    
    -- 统计范围
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    
    -- 账户范围
    total_accounts INTEGER DEFAULT 0,
    checked_accounts INTEGER DEFAULT 0,
    error_accounts INTEGER DEFAULT 0,
    
    -- 金额统计
    redis_total_balance NUMERIC DEFAULT 0,
    db_total_balance NUMERIC DEFAULT 0,
    balance_diff_total NUMERIC DEFAULT 0,
    
    redis_total_consumed NUMERIC DEFAULT 0,
    db_total_consumed NUMERIC DEFAULT 0,
    consumed_diff_total NUMERIC DEFAULT 0,
    
    -- 差异详情
    accounts_with_diff INTEGER DEFAULT 0,
    max_diff_amount NUMERIC DEFAULT 0,
    avg_diff_amount NUMERIC DEFAULT 0,
    
    -- 分类差异
    diff_by_type JSONB DEFAULT '{}',  -- 按差异类型分类
    
    -- 报告状态
    report_status VARCHAR(20) DEFAULT 'generating',  -- generating, completed, error
    generation_duration_ms INTEGER,
    
    -- 审计
    generated_by VARCHAR(100) DEFAULT 'system',
    generated_at TIMESTAMP DEFAULT NOW(),
    reviewed_by UUID,
    reviewed_at TIMESTAMP,
    
    -- 存储报告文件/摘要
    report_summary TEXT,
    report_details JSONB,
    storage_path TEXT,
    
    -- 索引
    UNIQUE(report_date, report_type)
);

CREATE INDEX idx_reconciliation_date ON data.reconciliation_report(report_date DESC);
CREATE INDEX idx_reconciliation_status ON data.reconciliation_report(report_status);
```

### **阶段三：函数和触发器（可选，用于自动化）**

#### **3.1 创建余额计算函数**
```sql
CREATE OR REPLACE FUNCTION data.calculate_account_balance(p_account_id UUID)
RETURNS TABLE (
    current_balance NUMERIC,
    calculated_balance NUMERIC,
    total_consumed NUMERIC,
    last_activity TIMESTAMP
) AS $$
DECLARE
    v_account_record RECORD;
BEGIN
    -- 获取账户信息
    SELECT * INTO v_account_record 
    FROM data.account_balance 
    WHERE id = p_account_id;
    
    IF NOT FOUND THEN
        RETURN;
    END IF;
    
    -- 计算理论余额（基于审计流水）
    RETURN QUERY
    WITH balance_calc AS (
        SELECT 
            -- 当前余额
            ab.balance as current_balance,
            
            -- 计算的理论余额
            COALESCE((
                SELECT SUM(
                    CASE 
                        WHEN action IN ('TOPUP', 'ADJUSTMENT_INCREASE') THEN amount
                        WHEN action IN ('USAGE', 'FEE', 'ADJUSTMENT_DECREASE') THEN -amount
                        ELSE 0
                    END
                )
                FROM data.account_balance_audit aba
                WHERE aba.account_id = ab.id
            ), 0) as calculated_balance,
            
            -- 总消费
            COALESCE((
                SELECT SUM(cost)
                FROM data.usage_log ul
                WHERE (ul.account_id = ab.id OR ul.user_id = ab.owner_userid)
            ), 0) as total_consumed,
            
            -- 最后活动时间
            GREATEST(
                ab.updated_at,
                (SELECT MAX(created_at) FROM data.account_balance_audit WHERE account_id = ab.id),
                (SELECT MAX(created_at) FROM data.usage_log WHERE account_id = ab.id)
            ) as last_activity
            
        FROM data.account_balance ab
        WHERE ab.id = p_account_id
    )
    SELECT * FROM balance_calc;
END;
$$ LANGUAGE plpgsql;
```

#### **3.2 创建异步写入完成触发器**
```sql
-- 当usage_log写入完成时，更新账户统计
CREATE OR REPLACE FUNCTION data.update_account_on_usage_log()
RETURNS TRIGGER AS $$
BEGIN
    -- 异步更新账户的总消费（非实时）
    UPDATE data.account_balance 
    SET 
        total_consumed = total_consumed + NEW.cost,
        last_balance_calc = NOW()
    WHERE id = NEW.account_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 只在sync_status为completed时触发
CREATE TRIGGER trigger_after_usage_log_completed
AFTER INSERT OR UPDATE ON data.usage_log
FOR EACH ROW
WHEN (NEW.sync_status = 'completed' AND (OLD.sync_status IS NULL OR OLD.sync_status != 'completed'))
EXECUTE FUNCTION data.update_account_on_usage_log();
```

### **关键设计要点总结**

1. **双余额设计**：`balance`（DB计算） + `redis_balance`（Redis同步）
2. **防重放机制**：`deduction_id`唯一约束保证幂等性
3. **异步状态追踪**：所有表都有`sync_status`字段
4. **版本控制**：乐观锁防止并发冲突
5. **审计完整性**：即使异步，也保证流水记录完整
6. **对账支持**：专门的表记录同步差异
7. **向后兼容**：逐步迁移，不影响现有业务

这个设计方案支持：
- 高频实时扣费（Redis）
- 异步持久化（BillingWorker）
- 自动对账修复
- 实时+最终一致性查询
- 完整的审计追溯

# **余额最后更新到：**

1. **Redis**：实时更新（API Gateway扣费时）
2. **account_balance**：批量更新（BillingWorker定时同步）
3. **account_balance_audit**：每笔记录（触发器或BillingWorker写入）

**更新的时机**：

- 实时扣费 → 立即更新Redis
- 异步同步 → 定期更新account_balance（如每分钟）
- 流水记录 → 每次操作都写audit表



