# æ”¯ä»˜è®¾è®¡

## è¡¨

### fund_transactions

```postgresql
CREATE TABLE IF NOT EXISTS data.fund_transactions
(
    id bigint NOT NULL DEFAULT nextval('data.fund_transactions_id_seq'::regclass),
    user_id uuid NOT NULL,
    account_type text COLLATE pg_catalog."default" NOT NULL,
    transaction_type text COLLATE pg_catalog."default" NOT NULL,
    amount numeric(15,6) NOT NULL,
    currency text COLLATE pg_catalog."default" NOT NULL DEFAULT 'USD'::character varying,
    balance_before numeric(15,6) NOT NULL,
    balance_after numeric(15,6) NOT NULL,
    reference_id text COLLATE pg_catalog."default",
    operator_id uuid,
    operator_type text COLLATE pg_catalog."default" DEFAULT 'system'::character varying,
    description text COLLATE pg_catalog."default",
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT fund_transactions_pkey PRIMARY KEY (id),
    CONSTRAINT fund_transactions_operator_type_check CHECK (operator_type = ANY (ARRAY['system'::text, 'admin'::text, 'user'::text])),
    CONSTRAINT check_amount_sign CHECK ((transaction_type = ANY (ARRAY['deposit'::text, 'refund'::text])) AND amount > 0::numeric OR transaction_type = 'adjustment'::text AND amount <> 0::numeric),
    CONSTRAINT check_balance_consistency CHECK (balance_after = (balance_before + amount)),
    CONSTRAINT fund_transactions_account_type_check CHECK (account_type = ANY (ARRAY['user'::text, 'tenant'::text])),
    CONSTRAINT fund_transactions_transaction_type_check CHECK (transaction_type = ANY (ARRAY['deposit'::text, 'refund'::text, 'adjustment'::text]))
)

COMMENT ON TABLE data.fund_transactions
    IS 'èµ„é‡‘æµæ°´è¡¨ï¼šè®°å½•æ‰€æœ‰éAPIæ¶ˆè´¹çš„èµ„é‡‘å˜åŠ¨ï¼ˆå……å€¼ã€é€€æ¬¾ã€è°ƒæ•´ç­‰ï¼‰';
```

### payment_jobs

```postgresql
CREATE TABLE IF NOT EXISTS data.payment_jobs
(
    id bigint NOT NULL DEFAULT nextval('data.payment_jobs_id_seq'::regclass),
    payment_intent_id text COLLATE pg_catalog."default" NOT NULL,
    order_id text COLLATE pg_catalog."default" NOT NULL,
    user_id uuid NOT NULL,
    channel text COLLATE pg_catalog."default" NOT NULL,
    amount numeric(15,6) NOT NULL,
    currency text COLLATE pg_catalog."default" NOT NULL DEFAULT 'CNY'::text,
    status text COLLATE pg_catalog."default" NOT NULL DEFAULT 'pending'::text,
    run_at timestamp with time zone NOT NULL DEFAULT now(),
    locked_by text COLLATE pg_catalog."default",
    locked_at timestamp with time zone,
    attempts integer NOT NULL DEFAULT 0,
    max_attempts integer NOT NULL DEFAULT 3,
    last_error text COLLATE pg_catalog."default",
    provider_tx_id text COLLATE pg_catalog."default",
    provider_status text COLLATE pg_catalog."default",
    provider_raw_resp jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT payment_jobs_pkey PRIMARY KEY (id),
    CONSTRAINT ux_payment_intent UNIQUE (payment_intent_id),
    CONSTRAINT check_lock_consistency CHECK (status = 'processing'::text AND locked_by IS NOT NULL AND locked_at IS NOT NULL OR status <> 'processing'::text AND locked_by IS NULL AND locked_at IS NULL),
    CONSTRAINT payment_jobs_amount_check CHECK (amount > 0::numeric),
    CONSTRAINT payment_jobs_channel_check CHECK (channel = ANY (ARRAY['alipay'::text, 'wechat_pay'::text, 'stripe'::text])),
    CONSTRAINT payment_jobs_status_check CHECK (status = ANY (ARRAY['pending'::text, 'processing'::text, 'success'::text, 'failed'::text, 'timeout'::text, 'canceled'::text]))
)

COMMENT ON TABLE data.payment_jobs
    IS 'æ”¯ä»˜è°ƒåº¦è¡¨ï¼šç®¡ç†æ”¯ä»˜ä»»åŠ¡çš„çŠ¶æ€æœºã€é‡è¯•å’Œå¹¶å‘æ§åˆ¶';

COMMENT ON COLUMN data.payment_jobs.id
    IS 'ä¸»é”®ID';

COMMENT ON COLUMN data.payment_jobs.payment_intent_id
    IS 'æ”¯ä»˜æ„å›¾IDï¼šä¸šåŠ¡å”¯ä¸€æ ‡è¯†ï¼Œé˜²é‡æ ¸å¿ƒ';

COMMENT ON COLUMN data.payment_jobs.order_id
    IS 'å…³è”è®¢å•ID';

COMMENT ON COLUMN data.payment_jobs.user_id
    IS 'ç”¨æˆ·ID';

COMMENT ON COLUMN data.payment_jobs.channel
    IS 'æ”¯ä»˜æ¸ é“ï¼šalipay/wechat_pay/stripe';

COMMENT ON COLUMN data.payment_jobs.amount
    IS 'æ”¯ä»˜é‡‘é¢';

COMMENT ON COLUMN data.payment_jobs.currency
    IS 'è´§å¸ç±»å‹ï¼šCNY/USDç­‰';

COMMENT ON COLUMN data.payment_jobs.status
    IS 'çŠ¶æ€ï¼špendingå¾…å¤„ç†/processingå¤„ç†ä¸­/successæˆåŠŸ/failedå¤±è´¥/timeoutè¶…æ—¶/canceledå–æ¶ˆ';

COMMENT ON COLUMN data.payment_jobs.run_at
    IS 'ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´ï¼šç”¨äºè°ƒåº¦æ§åˆ¶';

COMMENT ON COLUMN data.payment_jobs.locked_by
    IS 'é”å®šWorkeræ ‡è¯†';

COMMENT ON COLUMN data.payment_jobs.locked_at
    IS 'é”å®šæ—¶é—´ï¼šç”¨äºè¶…æ—¶é‡Šæ”¾';

COMMENT ON COLUMN data.payment_jobs.attempts
    IS 'å·²å°è¯•æ¬¡æ•°';

COMMENT ON COLUMN data.payment_jobs.max_attempts
    IS 'æœ€å¤§é‡è¯•æ¬¡æ•°';

COMMENT ON COLUMN data.payment_jobs.last_error
    IS 'æœ€åä¸€æ¬¡é”™è¯¯ä¿¡æ¯';

COMMENT ON COLUMN data.payment_jobs.provider_tx_id
    IS 'æ”¯ä»˜æ¸ é“äº¤æ˜“å·ï¼šæ”¯ä»˜å®/å¾®ä¿¡äº¤æ˜“ID';

COMMENT ON COLUMN data.payment_jobs.provider_status
    IS 'æ”¯ä»˜æ¸ é“è¿”å›çŠ¶æ€';

COMMENT ON COLUMN data.payment_jobs.provider_raw_resp
    IS 'æ”¯ä»˜æ¸ é“åŸå§‹å“åº”';

COMMENT ON COLUMN data.payment_jobs.created_at
    IS 'åˆ›å»ºæ—¶é—´';

COMMENT ON COLUMN data.payment_jobs.updated_at
    IS 'æœ€åæ›´æ–°æ—¶é—´';
-- Index: idx_payment_jobs_order

-- DROP INDEX IF EXISTS data.idx_payment_jobs_order;

CREATE INDEX IF NOT EXISTS idx_payment_jobs_order
    ON data.payment_jobs USING btree
    (order_id COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_payment_jobs_schedule

-- DROP INDEX IF EXISTS data.idx_payment_jobs_schedule;

CREATE INDEX IF NOT EXISTS idx_payment_jobs_schedule
    ON data.payment_jobs USING btree
    (status COLLATE pg_catalog."default" ASC NULLS LAST, run_at ASC NULLS LAST, id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default
    WHERE status = ANY (ARRAY['pending'::text, 'timeout'::text]);
-- Index: idx_payment_jobs_user

-- DROP INDEX IF EXISTS data.idx_payment_jobs_user;

CREATE INDEX IF NOT EXISTS idx_payment_jobs_user
    ON data.payment_jobs USING btree
    (user_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;

-- Trigger: payment_job_created_notify

-- DROP TRIGGER IF EXISTS payment_job_created_notify ON data.payment_jobs;

CREATE OR REPLACE TRIGGER payment_job_created_notify
    AFTER INSERT
    ON data.payment_jobs
    FOR EACH ROW
    EXECUTE FUNCTION data.notify_payment_job_created();

-- Trigger: payment_job_updated_notify

-- DROP TRIGGER IF EXISTS payment_job_updated_notify ON data.payment_jobs;

CREATE OR REPLACE TRIGGER payment_job_updated_notify
    AFTER UPDATE 
    ON data.payment_jobs
    FOR EACH ROW
    EXECUTE FUNCTION data.notify_payment_job_updated();
```

## nodejs worker

```js
// payment_worker.js
const { Pool, Client } = require('pg')
const { createPayment } = require('./payment_gateway')
const logger = require('./logger')

let isRunning = false
let notifyClient = null
let dbPool = null
const processingJobs = new Set()

// å¯åŠ¨worker
async function startWorker() {
  if (isRunning) return
  
  isRunning = true
  
  // æ•°æ®åº“è¿æ¥æ± 
  dbPool = new Pool({
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    max: 10,
  })
  
  // é€šçŸ¥å®¢æˆ·ç«¯
  notifyClient = new Client({
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
  })
  
  try {
    await notifyClient.connect()
    await notifyClient.query('LISTEN payment_jobs')
    
    notifyClient.on('notification', async (msg) => {
      const jobId = parseInt(msg.payload)
      if (!processingJobs.has(jobId)) {
        processingJobs.add(jobId)
        setTimeout(() => processJob(jobId), 0)
      }
    })
    
    // å¤„ç†å¯åŠ¨æ—¶å¯èƒ½å­˜åœ¨çš„pendingä»»åŠ¡
    await processExistingJobs()
    
    logger.info(`Payment worker started, listening for notifications`)
    
  } catch (error) {
    logger.error('Failed to start worker', { error: error.message })
    await stopWorker()
    process.exit(1)
  }
}

// å¤„ç†æ•°æ®åº“é€šçŸ¥
async function processJob(jobId) {
  try {
    const job = await acquireJob(jobId)
    if (job) {
      await executePayment(job)
    }
  } catch (error) {
    logger.error('Job processing failed', { jobId, error: error.message })
  } finally {
    processingJobs.delete(jobId)
  }
}

// æŠ¢å ä»»åŠ¡
async function acquireJob(jobId) {
  const client = await dbPool.connect()
  
  try {
    await client.query('BEGIN')
    
    const result = await client.query(`
      UPDATE payment_jobs
      SET 
        status = 'processing',
        locked_by = $1,
        locked_at = now(),
        attempts = attempts + 1
      WHERE id = $2
        AND status IN ('pending', 'timeout')
        AND run_at <= now()
        AND attempts < max_attempts
      RETURNING *
    `, [`worker-${process.pid}`, jobId])
    
    await client.query('COMMIT')
    return result.rows[0]
    
  } catch (error) {
    await client.query('ROLLBACK')
    return null
  } finally {
    client.release()
  }
}

// æ‰§è¡Œæ”¯ä»˜
async function executePayment(job) {
  logger.info('Executing payment', { 
    jobId: job.id, 
    channel: job.channel,
    amount: job.amount 
  })
  
  try {
    // ğŸš€ è°ƒç”¨æ”¯ä»˜ç½‘å…³
    const paymentResult = await createPayment({
      channel: job.channel,
      amount: job.amount,
      currency: job.currency,
      paymentIntentId: job.payment_intent_id,
      orderId: job.order_id,
      userId: job.user_id
    })
    
    // æ”¯ä»˜æˆåŠŸ
    await handlePaymentSuccess(job, paymentResult)
    
  } catch (error) {
    // æ”¯ä»˜å¤±è´¥
    await handlePaymentFailure(job, error)
  }
}

// æ”¯ä»˜æˆåŠŸå¤„ç†
async function handlePaymentSuccess(job, paymentResult) {
  const client = await dbPool.connect()
  
  try {
    await client.query('BEGIN')
    
    // æ›´æ–°payment_jobs
    const updateResult = await client.query(`
      UPDATE payment_jobs
      SET 
        status = 'success',
        provider_tx_id = $1,
        provider_status = $2,
        provider_raw_resp = $3,
        locked_by = NULL,
        locked_at = NULL
      WHERE id = $4
        AND status <> 'success'
      RETURNING id
    `, [
      paymentResult.providerTxId,
      paymentResult.status,
      paymentResult.rawResponse,
      job.id
    ])
    
    if (updateResult.rows.length === 0) {
      await client.query('COMMIT')
      return // å·²ç»æ˜¯æˆåŠŸçŠ¶æ€
    }
    
    // æ’å…¥èµ„é‡‘æµæ°´
    await client.query(`
      INSERT INTO fund_transactions (
        user_id, account_type, transaction_type,
        amount, currency, balance_before, balance_after,
        reference_id, description
      )
      SELECT 
        $1, 'user', 'deposit',
        $2, $3, ab.balance, ab.balance + $2,
        $4, $5
      FROM account_balance ab
      WHERE ab.user_id = $1
      ON CONFLICT (reference_id) DO NOTHING
    `, [
      job.user_id,
      job.amount,
      job.currency,
      job.payment_intent_id,
      `åœ¨çº¿å……å€¼ï¼ˆ${job.channel}ï¼‰`
    ])
    
    // æ›´æ–°è´¦æˆ·ä½™é¢
    await client.query(`
      UPDATE account_balance
      SET 
        balance = balance + $1,
        total_deposit = total_deposit + $1
      WHERE user_id = $2
    `, [job.amount, job.user_id])
    
    await client.query('COMMIT')
    
    logger.info('Payment succeeded', { 
      jobId: job.id,
      providerTxId: paymentResult.providerTxId 
    })
    
  } catch (error) {
    await client.query('ROLLBACK')
    logger.error('Failed to process payment success', { 
      jobId: job.id,
      error: error.message 
    })
  } finally {
    client.release()
  }
}

// æ”¯ä»˜å¤±è´¥å¤„ç†
async function handlePaymentFailure(job, error) {
  const isFinal = job.attempts >= job.max_attempts
  const nextRunAt = new Date(Date.now() + Math.pow(2, job.attempts) * 60000)
  
  try {
    await dbPool.query(`
      UPDATE payment_jobs
      SET 
        status = $1,
        last_error = $2,
        run_at = $3,
        locked_by = NULL,
        locked_at = NULL
      WHERE id = $4
    `, [
      isFinal ? 'failed' : 'pending',
      error.message.substring(0, 500),
      nextRunAt,
      job.id
    ])
    
    logger[isFinal ? 'error' : 'warn']('Payment failed', {
      jobId: job.id,
      attempts: job.attempts,
      error: error.message,
      nextRunAt: isFinal ? null : nextRunAt
    })
    
  } catch (dbError) {
    logger.error('Failed to update payment failure', { 
      jobId: job.id,
      error: dbError.message 
    })
  }
}

// å¤„ç†å¯åŠ¨æ—¶å­˜åœ¨çš„ä»»åŠ¡
async function processExistingJobs() {
  try {
    const result = await dbPool.query(`
      SELECT id FROM payment_jobs 
      WHERE status IN ('pending', 'timeout')
        AND run_at <= now()
      ORDER BY run_at
      LIMIT 10
    `)
    
    for (const row of result.rows) {
      if (!processingJobs.has(row.id)) {
        processingJobs.add(row.id)
        setTimeout(() => processJob(row.id), Math.random() * 1000) // éšæœºå»¶è¿Ÿé¿å…å¹¶å‘
      }
    }
  } catch (error) {
    logger.error('Failed to process existing jobs', { error: error.message })
  }
}

// åœæ­¢worker
async function stopWorker() {
  isRunning = false
  
  if (notifyClient) {
    await notifyClient.end()
  }
  
  if (dbPool) {
    await dbPool.end()
  }
  
  logger.info('Payment worker stopped')
}

// ä¿¡å·å¤„ç†
process.on('SIGTERM', stopWorker)
process.on('SIGINT', stopWorker)

// å¯åŠ¨
if (require.main === module) {
  startWorker().catch(error => {
    logger.error('Worker startup failed', { error: error.message })
    process.exit(1)
  })
}

module.exports = { startWorker, stopWorker }
```

## payment_gateways.js

```js
// payment_gateway.js
const logger = require('./logger')

// ğŸš€ æ”¯ä»˜ç½‘å…³æ¥å£
async function createPayment(params) {
  const { channel, amount, currency, paymentIntentId, orderId, userId } = params
  
  logger.info('Creating payment', { channel, amount, paymentIntentId })
  
  // =============================================
  // TODO: å®ç°å…·ä½“çš„ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¥å£è°ƒç”¨
  // =============================================
  
  // ç¤ºä¾‹ï¼šæ”¯ä»˜å®æ”¯ä»˜
  if (channel === 'alipay') {
    // const result = await alipaySdk.exec('alipay.trade.create', {
    //   bizContent: {
    //     out_trade_no: paymentIntentId,
    //     total_amount: amount,
    //     subject: `è®¢å•æ”¯ä»˜ - ${orderId}`,
    //     buyer_id: userId,
    //   }
    // })
    
    // æ¨¡æ‹Ÿå®ç°
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    if (Math.random() < 0.05) { // 5%å¤±è´¥ç‡æµ‹è¯•
      throw new Error('ALIPAY_NETWORK_ERROR')
    }
    
    return {
      success: true,
      providerTxId: `ALIPAY${Date.now()}${Math.random().toString(36).substr(2, 6)}`,
      status: 'SUCCESS',
      rawResponse: {
        trade_no: `2024${Date.now()}`,
        out_trade_no: paymentIntentId,
        total_amount: amount,
      }
    }
  }
  
  throw new Error(`Unsupported payment channel: ${channel}`)
}

module.exports = { createPayment }
```

## pg_cron æ¸…ç†

```postgresql
-- 1. å®‰è£…æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. é…ç½® cron ä»»åŠ¡ï¼šæ¯5åˆ†é’Ÿæ¸…ç†å¡ä½çš„ä»»åŠ¡
SELECT cron.schedule(
  'release-stuck-payments',
  '*/5 * * * *',  -- æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
  $$
    UPDATE data.payment_jobs
    SET 
      status = 'timeout',
      locked_by = NULL,
      locked_at = NULL,
      run_at = now(),
      last_error = 'Processing timeout - auto released by pg_cron',
      updated_at = now()
    WHERE status = 'processing'
      AND locked_at < now() - interval '10 minutes';
  $$
);

-- 3. æŸ¥çœ‹å·²é…ç½®çš„ä»»åŠ¡
SELECT * FROM cron.job;

-- 4. æ‰‹åŠ¨æµ‹è¯•æ‰§è¡Œ
SELECT cron.run_scheduled_task('release-stuck-payments');
```

### æ¸…ç†å‡½æ•°

```postgresql
CREATE OR REPLACE FUNCTION data.release_stuck_payments()
RETURNS TABLE(released_count int, job_ids bigint[]) AS $$
DECLARE
  released_ids bigint[];
BEGIN
  WITH stuck_jobs AS (
    SELECT id
    FROM data.payment_jobs
    WHERE status = 'processing'
      AND locked_at < now() - interval '10 minutes'
    FOR UPDATE SKIP LOCKED
  ),
  released AS (
    UPDATE data.payment_jobs pj
    SET 
      status = 'timeout',
      locked_by = NULL,
      locked_at = NULL,
      run_at = now(),
      last_error = 'Processing timeout - auto released',
      updated_at = now()
    FROM stuck_jobs sj
    WHERE pj.id = sj.id
    RETURNING pj.id
  )
  SELECT 
    COUNT(*),
    ARRAY_AGG(id)
  INTO released_count, job_ids
  FROM released;
  
  -- é€šçŸ¥workeræœ‰æ–°ä»»åŠ¡å¯å¤„ç†
  IF released_count > 0 THEN
    PERFORM pg_notify('payment_jobs', 'timeout_released');
  END IF;
  
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql;

-- æ›´æ–°cronä»»åŠ¡ä½¿ç”¨å‡½æ•°
SELECT cron.unschedule('release-stuck-payments');

SELECT cron.schedule(
  'release-stuck-payments',
  '*/5 * * * *',
  'SELECT data.release_stuck_payments();'
);
```

### worker é€‚é…pg_cronçš„é€šçŸ¥

```javascript
// payment_worker.js æ›´æ–°é€šçŸ¥å¤„ç†
notifyClient.on('notification', async (msg) => {
  if (msg.channel === 'payment_jobs') {
    if (msg.payload === 'timeout_released') {
      // æ‰¹é‡å¤„ç†è¶…æ—¶é‡Šæ”¾çš„ä»»åŠ¡
      await processTimeoutJobs()
    } else {
      const jobId = parseInt(msg.payload)
      if (!processingJobs.has(jobId)) {
        processingJobs.add(jobId)
        setTimeout(() => processJob(jobId), 0)
      }
    }
  }
})

// æ‰¹é‡å¤„ç†è¶…æ—¶ä»»åŠ¡
async function processTimeoutJobs() {
  const result = await dbPool.query(`
    SELECT id FROM data.payment_jobs 
    WHERE status = 'timeout'
      AND run_at <= now()
    ORDER BY run_at
    LIMIT 20
  `)
  
  for (const row of result.rows) {
    if (!processingJobs.has(row.id)) {
      processingJobs.add(row.id)
      setTimeout(() => processJob(row.id), Math.random() * 1000)
    }
  }
}
```

è¿™æ˜¯ä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„æ”¯ä»˜ç³»ç»Ÿå®ç°ï¼ŒåŒ…å«å®Œæ•´çš„æ•°æ®åº“è®¾è®¡ã€å¼‚æ­¥ä»»åŠ¡å¤„ç†å’Œå®¹é”™æœºåˆ¶ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„è®¾è®¡è¯´æ˜ï¼š

# è®¾è®¡è¯´æ˜

### 1. æ ¸å¿ƒè®¾è®¡ç†å¿µ
- **å¼‚æ­¥æ”¯ä»˜å¤„ç†**ï¼šé‡‡ç”¨Job Queueæ¨¡å¼ï¼Œå®ç°æ”¯ä»˜æµç¨‹çš„è§£è€¦å’Œå¼‚æ­¥æ‰§è¡Œ
- **æœ€ç»ˆä¸€è‡´æ€§**ï¼šä¿è¯æ”¯ä»˜ç»“æœçš„ä¸€è‡´æ€§ï¼Œæ”¯æŒé‡è¯•å’Œå¹‚ç­‰æ€§
- **å®¹é”™å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†ã€è¶…æ—¶æ¢å¤å’ŒçŠ¶æ€æœºç®¡ç†

### 2. ç³»ç»Ÿæµç¨‹å›¾
```
ç”¨æˆ·è¯·æ±‚ â†’ åˆ›å»ºPaymentJob â†’ å¼‚æ­¥Workerå¤„ç† â†’ 
â†’ è°ƒç”¨æ”¯ä»˜ç½‘å…³ â†’ å¤„ç†ç»“æœ â†’ æ›´æ–°ä½™é¢ â†’ å®Œæˆ
```

## äºŒã€æ•°æ®åº“è®¾è®¡åˆ†æ

### `fund_transactions` è¡¨
**ä¼˜ç‚¹ï¼š**
1. **å®Œæ•´æ€§çº¦æŸå¼ºå¤§**ï¼š
   - `check_amount_sign`ï¼šç¡®ä¿é‡‘é¢ç¬¦å·ä¸äº¤æ˜“ç±»å‹åŒ¹é…
   - `check_balance_consistency`ï¼šå¼ºåˆ¶ä½™é¢å‰åä¸€è‡´æ€§
   - æšä¸¾å€¼æ ¡éªŒä¿è¯æ•°æ®æœ‰æ•ˆæ€§

2. **å®¡è®¡è·Ÿè¸ªå®Œå–„**ï¼š
   - è®°å½•æ“ä½œè€…å’Œæ—¶é—´æˆ³
   - æ”¯æŒå…ƒæ•°æ®å­˜å‚¨ï¼ˆmetadataå­—æ®µï¼‰
   - ä½™é¢å‰åå¿«ç…§è®°å½•

**å»ºè®®æ”¹è¿›ï¼š**
1. æ·»åŠ `user_id`å’Œ`reference_id`çš„å¤åˆå”¯ä¸€çº¦æŸï¼Œé˜²æ­¢é‡å¤è®°è´¦
2. è€ƒè™‘æ·»åŠ `parent_transaction_id`å­—æ®µï¼Œæ”¯æŒé€€æ¬¾æº¯æº

### `payment_jobs` è¡¨
**äº®ç‚¹è®¾è®¡ï¼š**
1. **çŠ¶æ€æœºæ˜ç¡®**ï¼š6ç§çŠ¶æ€æ¸…æ™°å®šä¹‰ç”Ÿå‘½å‘¨æœŸ
2. **å¹¶å‘æ§åˆ¶**ï¼šé”å®šæœºåˆ¶é˜²æ­¢é‡å¤å¤„ç†
3. **é‡è¯•ç­–ç•¥**ï¼šæŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶
4. **å®Œæ•´å®¡è®¡**ï¼šä¿ç•™æ”¯ä»˜æ¸ é“åŸå§‹å“åº”

**ç´¢å¼•è®¾è®¡ä¼˜ç§€ï¼š**
- `idx_payment_jobs_schedule`ï¼šè¦†ç›–æŸ¥è¯¢ä¼˜åŒ–ï¼ˆä½¿ç”¨éƒ¨åˆ†ç´¢å¼•ï¼‰
- `idx_payment_jobs_order`ï¼šè®¢å•æŸ¥è¯¢ä¼˜åŒ–
- `idx_payment_jobs_user`ï¼šç”¨æˆ·ç»´åº¦æŸ¥è¯¢

**è§¦å‘å™¨å’Œé€šçŸ¥**ï¼šå®ç°å®æ—¶ä»»åŠ¡è°ƒåº¦ï¼Œå“åº”è¿…é€Ÿ

## ä¸‰ã€Workerå®ç°åˆ†æ

### ä¼˜åŠ¿ï¼š
1. **æŠ¢å å¼ä»»åŠ¡å¤„ç†**ï¼šä½¿ç”¨æ•°æ®åº“é”å®ç°åˆ†å¸ƒå¼é”
2. **ä¼˜é›…çš„å…³é—­å¤„ç†**ï¼šæ”¯æŒSIGTERM/SIGINTä¿¡å·
3. **å†…å­˜ç®¡ç†**ï¼šä½¿ç”¨Setè·Ÿè¸ªå¤„ç†ä¸­çš„ä»»åŠ¡ï¼Œé¿å…é‡å¤å¤„ç†
4. **éšæœºå»¶è¿Ÿå¯åŠ¨**ï¼šé¿å…å¯åŠ¨æ—¶å¹¶å‘é£æš´

### æ½œåœ¨é—®é¢˜åŠå»ºè®®ï¼š

1. **æ•°æ®åº“è¿æ¥ç®¡ç†**
```javascript
// å»ºè®®ï¼šè¿æ¥æ± é…ç½®ä¼˜åŒ–
const dbPool = new Pool({
  // ... ç°æœ‰é…ç½®
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
  maxUses: 7500, // é˜²æ­¢è¿æ¥æ³„éœ²
})
```

2. **å†…å­˜æ³„æ¼é£é™©**
```javascript
// å»ºè®®ï¼šæ·»åŠ è¶…æ—¶æ¸…ç†
setInterval(() => {
  const now = Date.now()
  // æ¸…ç†å¤„ç†æ—¶é—´è¿‡é•¿çš„ä»»åŠ¡ï¼ˆå‡è®¾æ¯ä¸ªä»»åŠ¡æœ‰startTimeè®°å½•ï¼‰
}, 60000)
```

3. **æ‰¹é‡å¤„ç†ä¼˜åŒ–**
```javascript
// å»ºè®®ï¼šæ”¯æŒæ‰¹é‡è·å–ä»»åŠ¡
async function acquireJobs(batchSize = 5) {
  // ä¸€æ¬¡æ€§è·å–å¤šä¸ªä»»åŠ¡ï¼Œå‡å°‘æ•°æ®åº“å¾€è¿”
}
```

## å››ã€æ”¯ä»˜ç½‘å…³å®ç°

### ç°çŠ¶ï¼š
- æä¾›äº†æ¡†æ¶ç»“æ„
- æ”¯æŒå¤šç§æ”¯ä»˜æ¸ é“
- åŒ…å«æ¨¡æ‹Ÿå®ç°å’Œé”™è¯¯æµ‹è¯•

### å»ºè®®æ‰©å±•ï¼š
1. **æ¸ é“é…ç½®åŒ–ç®¡ç†**
```javascript
// å»ºè®®ï¼šé…ç½®é©±åŠ¨
const channelConfigs = {
  alipay: { timeout: 30000, retryable: true },
  wechat_pay: { timeout: 25000, retryable: true },
  stripe: { timeout: 15000, retryable: false }
}
```

2. **æ·»åŠ Webhookå¤„ç†**
```javascript
// å»ºè®®ï¼šæ”¯ä»˜ç»“æœå›è°ƒéªŒè¯
async function verifyWebhook(signature, payload) {
  // éªŒè¯æ”¯ä»˜æ¸ é“å›è°ƒçš„ç­¾å
}
```

## äº”ã€pg_cronæ¸…ç†æœºåˆ¶

### ä¼˜ç‚¹ï¼š
1. **è‡ªåŠ¨æ¢å¤**ï¼šå®šæœŸé‡Šæ”¾å¡ä½çš„ä»»åŠ¡
2. **é€šçŸ¥æœºåˆ¶**ï¼šé‡Šæ”¾åé€šçŸ¥Workerå¤„ç†
3. **åŸå­æ€§æ“ä½œ**ï¼šä½¿ç”¨FOR UPDATE SKIP LOCKED

### å»ºè®®ä¼˜åŒ–ï¼š
1. **æ·»åŠ ç›‘æ§æŒ‡æ ‡**
```sql
-- å»ºè®®ï¼šè®°å½•æ¸…ç†ç»Ÿè®¡
CREATE TABLE payment_cleanup_logs (
  id serial PRIMARY KEY,
  cleaned_count int,
  avg_stuck_seconds numeric,
  cleaned_at timestamptz DEFAULT now()
);
```

2. **åˆ†çº§æ¸…ç†ç­–ç•¥**
```sql
-- å»ºè®®ï¼šæ ¹æ®å¡ä½æ—¶é—´åˆ†çº§å¤„ç†
CASE 
  WHEN locked_at < now() - interval '30 minutes' 
    THEN 'failed' -- å½»åº•å¤±è´¥
  WHEN locked_at < now() - interval '10 minutes' 
    THEN 'timeout' -- é‡è¯•
  ELSE 'keep' -- ä¿æŒ
END
```

## å…­ã€å®‰å…¨æ€§è€ƒè™‘

### å·²å®ç°çš„ï¼š
1. é‡‘é¢æ­£æ•°æ ¡éªŒ
2. çŠ¶æ€ä¸€è‡´æ€§æ ¡éªŒ
3. æ“ä½œè€…æƒé™è®°å½•

### å»ºè®®è¡¥å……ï¼š
1. **å¹‚ç­‰æ€§ä¿è¯**ï¼špayment_intent_idçš„å”¯ä¸€çº¦æŸå¾ˆå¥½
2. **æ•æ„Ÿä¿¡æ¯å¤„ç†**ï¼šå»ºè®®åŠ å¯†å­˜å‚¨provider_raw_respä¸­çš„æ•æ„Ÿæ•°æ®
3. **é‡‘é¢ç²¾åº¦**ï¼šnumeric(15,6)æ”¯æŒé«˜ç²¾åº¦è®¡ç®—

## ä¸ƒã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆ†åŒºè¡¨è®¾è®¡**
```sql
-- å¯¹äºå¤§è§„æ¨¡ç³»ç»Ÿï¼ŒæŒ‰æ—¶é—´åˆ†åŒº
CREATE TABLE payment_jobs_2024 PARTITION OF payment_jobs
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

2. **å½’æ¡£ç­–ç•¥**
```sql
-- å®šæœŸå½’æ¡£å®Œæˆçš„ä»»åŠ¡
CREATE TABLE payment_jobs_archive (LIKE payment_jobs INCLUDING ALL);
```

3. **Workeræ°´å¹³æ‰©å±•**
```javascript
// æ”¯æŒå¤šä¸ªWorkerå®ä¾‹
const workerId = `worker-${process.pid}-${Math.random().toString(36).substr(2, 6)}`;
```

## å…«ã€ç›‘æ§å’Œå‘Šè­¦å»ºè®®

1. **å…³é”®æŒ‡æ ‡ç›‘æ§**ï¼š
   - ä»»åŠ¡ç§¯å‹æ•°é‡
   - å¹³å‡å¤„ç†æ—¶é—´
   - å¤±è´¥ç‡
   - é‡è¯•ç‡

2. **å‘Šè­¦è§„åˆ™**ï¼š
   - è¿ç»­å¤±è´¥ä»»åŠ¡è¶…è¿‡é˜ˆå€¼
   - ä»»åŠ¡å¤„ç†æ—¶é—´è¶…è¿‡é¢„æœŸ
   - Workerå®ä¾‹å¼‚å¸¸é€€å‡º

## æ€»ç»“

è¿™æ˜¯ä¸€ä¸ª**è®¾è®¡è‰¯å¥½ã€è€ƒè™‘å‘¨å…¨**çš„æ”¯ä»˜ç³»ç»Ÿå®ç°ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### âœ… ä¼˜ç‚¹ï¼š
1. **æ¶æ„æ¸…æ™°**ï¼šåˆ†ç¦»äº†æ”¯ä»˜å¤„ç†ã€èµ„é‡‘ç®¡ç†å’Œä»»åŠ¡è°ƒåº¦
2. **å®¹é”™æ€§å¼º**ï¼šå®Œæ•´çš„é‡è¯•ã€è¶…æ—¶å’Œæ¢å¤æœºåˆ¶
3. **æ•°æ®ä¸€è‡´**ï¼šé€šè¿‡æ•°æ®åº“çº¦æŸå’Œäº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
4. **æ‰©å±•æ€§å¥½**ï¼šæ”¯æŒå¤šæ”¯ä»˜æ¸ é“ï¼Œæ˜“äºæ·»åŠ æ–°åŠŸèƒ½

### âš ï¸ æ³¨æ„äº‹é¡¹ï¼š
1. éœ€è¦å®Œæ•´çš„æµ‹è¯•è¦†ç›–ï¼ˆç‰¹åˆ«æ˜¯å¹¶å‘åœºæ™¯ï¼‰
2. å»ºè®®æ·»åŠ æ›´è¯¦ç»†çš„æ—¥å¿—å’Œç›‘æ§
3. è€ƒè™‘æ”¯ä»˜æ¸ é“çš„ç†”æ–­å’Œé™çº§ç­–ç•¥

# æ ¸å¿ƒ3è¡¨ä½“ç³»

```
payment_jobs (æ”¯ä»˜ä»»åŠ¡) â†’ fund_transactions (èµ„é‡‘æµæ°´) â†’ account_balance (ä½™é¢å¿«ç…§)
```

## è½å¸å‡½æ•°

```postgresql
CREATE OR REPLACE FUNCTION api.record_payment_deposit(
    p_user_id uuid,
    p_amount numeric(15,6),
    p_currency text,
    p_payment_intent_id text,
    p_channel text,
    p_provider_tx_id text,
    p_metadata jsonb DEFAULT '{}'::jsonb
) RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_old_balance numeric(15,6);
    v_new_balance numeric(15,6);
    v_transaction_id bigint;
BEGIN
    -- âœ… å‚æ•°éªŒè¯ï¼ˆé‡è¦ï¼ï¼‰
    IF p_amount <= 0 THEN
        RAISE EXCEPTION 'å……å€¼é‡‘é¢å¿…é¡»å¤§äº0ï¼Œå®é™…å€¼: %', p_amount;
    END IF;

    IF p_user_id IS NULL OR p_payment_intent_id IS NULL THEN
        RAISE EXCEPTION 'ç”¨æˆ·IDå’Œæ”¯ä»˜è®¢å•å·ä¸èƒ½ä¸ºç©º';
    END IF;

    -- âœ… é”å®šè´¦æˆ·ä½™é¢è¡Œï¼ˆé˜²æ­¢å¹¶å‘é‡å¤å……å€¼ï¼‰
    SELECT COALESCE(balance, 0) INTO v_old_balance
    FROM data.account_balance
    WHERE owner_userid = p_user_id
    FOR UPDATE;

    -- âœ… è®¡ç®—æ–°ä½™é¢
    v_new_balance := v_old_balance + p_amount;

    -- âœ… æ’å…¥èµ„é‡‘æµæ°´è®°å½•
    INSERT INTO data.fund_transactions (
        user_id, account_type, transaction_type,
        amount, currency, balance_before, balance_after,
        reference_id, operator_id, operator_type,
        description, metadata
    ) VALUES (
        p_user_id,
        'user',
        'deposit',
        p_amount,
        p_currency,
        v_old_balance,
        v_new_balance,
        p_payment_intent_id,
        p_user_id,
        'system',
        format('%sæ”¯ä»˜å……å€¼', p_channel),
        jsonb_build_object(
            'channel', p_channel,
            'provider_tx_id', p_provider_tx_id
        ) || p_metadata
    ) RETURNING id INTO v_transaction_id;

    -- âœ… æ›´æ–°è´¦æˆ·ä½™é¢ï¼ˆåŸå­æ“ä½œï¼‰
    INSERT INTO data.account_balance (
        owner_userid,
        balance,
        total_topup,
        last_transaction_id
    ) VALUES (
        p_user_id,
        p_amount,           -- æ–°æ’å…¥æ—¶åªå­˜æœ¬æ¬¡é‡‘é¢
        p_amount,
        v_transaction_id
    )
    ON CONFLICT (owner_userid)
    DO UPDATE SET
        balance = account_balance.balance + p_amount,
        total_topup = account_balance.total_topup + p_amount,
        last_transaction_id = v_transaction_id,
        updated_at = now();

    RETURN v_transaction_id;

EXCEPTION
    WHEN OTHERS THEN
        -- âœ… å¼‚å¸¸å¤„ç†ï¼Œè®°å½•é”™è¯¯ä½†ä¸å›æ»šï¼ˆè°ƒç”¨æ–¹å†³å®šï¼‰
        RAISE EXCEPTION 'è®°è´¦å¤±è´¥: %', SQLERRM;
END;
$$;

COMMENT ON FUNCTION api.record_payment_deposit(uuid, numeric, text, text, text, text, jsonb)
    IS '
è®°å½•æ”¯ä»˜æˆåŠŸçš„å……å€¼äº¤æ˜“

å‚æ•°è¯´æ˜ï¼š
- p_user_id: ç”¨æˆ·UUIDï¼Œå¿…å¡«
- p_amount: å……å€¼é‡‘é¢ï¼Œå¿…é¡»å¤§äº0ï¼Œnumeric(15,6)
- p_currency: è´§å¸ä»£ç ï¼Œå¦‚"CNY"ã€"USD"
- p_payment_intent_id: æ”¯ä»˜è®¢å•å·ï¼Œå…³è”payment_jobs.payment_intent_id
- p_channel: æ”¯ä»˜æ¸ é“ï¼Œå¦‚"alipay"ã€"wechat_pay"
- p_provider_tx_id: ç¬¬ä¸‰æ–¹æ”¯ä»˜äº¤æ˜“å·ï¼Œç”¨äºå¯¹è´¦
- p_metadata: æ‰©å±•ä¿¡æ¯ï¼ŒJSONæ ¼å¼ï¼Œé»˜è®¤ç©ºå¯¹è±¡

è¿”å›å€¼ï¼šfund_transactions.idï¼ˆèµ„é‡‘æµæ°´è®°å½•IDï¼‰

åŠŸèƒ½ï¼š
1. é”å®šç”¨æˆ·è´¦æˆ·ä½™é¢è¡Œ
2. æ’å…¥èµ„é‡‘æµæ°´è®°å½•åˆ°fund_transactions
3. æ›´æ–°è´¦æˆ·ä½™é¢åˆ°account_balance

è°ƒç”¨ç¤ºä¾‹ï¼š
SELECT data.record_payment_deposit(
    ''a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'', -- ç”¨æˆ·ID
    100.00,                                  -- å……å€¼é‡‘é¢
    ''CNY'',                                   -- è´§å¸
    ''pay_intent_202401010001'',               -- æ”¯ä»˜è®¢å•å·
    ''alipay'',                                -- æ”¯ä»˜æ¸ é“
    ''2024010123456789'',                      -- æ”¯ä»˜å®äº¤æ˜“å·
    ''{"order_id": "ORD123"}''::jsonb          -- æ‰©å±•ä¿¡æ¯
);

æ³¨æ„ï¼š
- æ­¤å‡½æ•°åªè´Ÿè´£è®°è´¦ï¼Œä¸å¤„ç†æ”¯ä»˜ä»»åŠ¡çŠ¶æ€
- è°ƒç”¨æ–¹éœ€ç¡®ä¿æ”¯ä»˜å·²æˆåŠŸ
- å‡½æ•°ä¸ºåŸå­æ“ä½œï¼ŒåŒ…å«å®Œæ•´çš„äº‹åŠ¡
';

```

## æ”¯ä»˜å…¨æµç¨‹

### **1. åˆ›å»ºæ”¯ä»˜ä»»åŠ¡**
```sql
INSERT INTO payment_jobs 
(payment_intent_id, user_id, amount, channel, status)
VALUES 
('pay_001', 'user-uuid', 100.00, 'alipay', 'pending');
```

### **2. æ”¯ä»˜workerå¤„ç†**
```python
# ä¼ªä»£ç 
job = get_next_pending_job()  # SELECT ... FOR UPDATE SKIP LOCKED

# è°ƒç”¨æ”¯ä»˜æ¸ é“
payment_result = call_payment_gateway(job)

if payment_result.success:
    # 1. æ›´æ–°æ”¯ä»˜ä»»åŠ¡çŠ¶æ€
    update_job_status(job.id, 'success', payment_result.tx_id)
    
    # 2. è®°è´¦
    transaction_id = db.execute("""
        SELECT data.record_payment_deposit(
            p_user_id => ?,
            p_amount => ?,
            p_currency => ?,
            p_payment_intent_id => ?,
            p_channel => ?,
            p_provider_tx_id => ?
        )
    """, job.user_id, job.amount, job.currency, 
        job.payment_intent_id, job.channel, payment_result.tx_id)
else:
    update_job_status(job.id, 'failed', payment_result.error)
```

### **3. è®°è´¦å‡½æ•°æ‰§è¡Œ**
```sql
-- record_payment_depositå†…éƒ¨ï¼š
-- 1. é”å®šaccount_balance
-- 2. æ’å…¥fund_transactions
-- 3. æ›´æ–°account_balance
-- è¿”å›transaction_id
```

### **4. æœ€ç»ˆçŠ¶æ€**
```
payment_jobs: 
    status='success', provider_tx_id='alipay_123'

fund_transactions:
    æ–°å¢ä¸€æ¡depositè®°å½•ï¼Œbalance_beforeâ†’balance_after

account_balance:
    balanceä»100â†’200ï¼ˆç´¯åŠ ï¼‰
```

### **æ ¸å¿ƒåŸåˆ™**
- **æ”¯ä»˜çŠ¶æ€** â†’ payment_jobsè¡¨ç®¡ç†
- **èµ„é‡‘è®°è´¦** â†’ record_payment_depositå‡½æ•°å¤„ç†
- **ä½™é¢æŸ¥è¯¢** â†’ account_balanceè¡¨ç›´æ¥è¯»å–

ä¸‰è¡¨åä½œï¼ŒèŒè´£æ¸…æ™°ã€‚

| event        | time | note                       | fund_transaction | account_balance                | redis_balance | usage_log                      |
| ------------ | ---- | -------------------------- | ---------------- | ------------------------------ | ------------- | ------------------------------ |
| topup 100    | t0   |                            | 100              | 100                            | 100           |                                |
| consume      | t1   |                            |                  |                                | -10 -> 90     | 10                             |
| consume      | t2   |                            |                  |                                | -30 -> 60     | 30                             |
| topup 20     | t3   | see balance from redis: 60 | 20               | 120                            | 60+20 -> 80   | å†™å…¥ä¸€æ¡ç‰¹æ®Šè®°å½•ä»¥åæ˜ æœ€æ–°ä½™é¢ |
| sync_balance | t4   |                            |                  | 120 - (sum usage_log: 40) = 80 |               | sum: 40                        |



report in time serials, from fund_transactions + usage_log

|      | event | in   | out  | balance |
| ---- | ----- | ---- | ---- | ------- |
| t0   |       | 100  |      | 100     |
| t1   |       |      | 10   | 90      |
| t2   |       |      | 30   | 60      |
| t3   |       | 20   |      | 80      |
