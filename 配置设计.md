# portkey gateway 配置说明
Portkey Gateway（开源版）对 schema 有明确的要求和规则，主要涉及两个方面：一是 `x-portkey-config` header 中的 JSON 配置 schema（使用 Zod 进行验证），二是 `jsonSchema` 插件用于输出验证的 JSON Schema（基于标准 JSON Schema 规范）。这些规则确保配置的安全性、一致性和有效性。下面我基于文档详细说明，包括要求、规则、示例和潜在约束。

### 1. `x-portkey-config` 的 Schema 要求
这是 Portkey Gateway 的核心配置，通过 HTTP header 传递一个 JSON 字符串。Gateway 在请求处理管道的验证阶段使用 **Zod**（一个 TypeScript 类型安全的 schema 验证库）来解析和验证这个 JSON（具体在 `src/middlewares/requestValidator.ts` 中定义的 `configSchema`）。如果不符合 schema，请求会失败（通常返回错误响应）。

#### 主要规则和要求：
- **整体结构**：必须是一个有效的 JSON 对象，支持递归嵌套（例如 `targets` 可以嵌套策略）。
- **必填字段**：某些字段如 `targets[].provider` 是必需的，其他如 `retry.attempts` 有默认值。
- **类型严格**：Zod 强制类型检查（例如 `weight` 必须是 number）。
- **值约束**：
  - 枚举值：如 `strategy.mode` 必须是特定字符串。
  - 范围：如 `retry.attempts` 限制在 1–5。
  - 数组元素：如 `on_status_codes` 必须是 HTTP 状态码数组。
- **提供商白名单**：`targets[].provider` 必须在 `VALID_PROVIDERS` 常量中（例如 "openai"、"anthropic"、"azure-openai" 等），否则验证失败。
- **忽略未知字段**：Zod 通常宽松处理未知字段，但核心字段必须符合。
- **安全验证**：额外检查 SSRF（服务器端请求伪造）风险，例如：
  - 禁止元数据端点（如 "169.254.169.254"）。
  - 过滤私有 IP 范围（如 10.0.0.0/8）。
  - 拒绝内部 TLD（如 .local）。
- **Header 和 Content-Type**：必须有正确的 `Content-Type`（如 application/json），否则无法解析。

#### 详细 Schema 属性（表格形式，便于参考）：
| 属性                        | 类型          | 描述                   | 约束/默认值                                                 | 示例                                                        |
| --------------------------- | ------------- | ---------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |
| `strategy.mode`             | string        | 路由策略模式           | 必须是 "loadbalance"、"fallback"、"conditional" 或 "single" | "loadbalance"                                               |
| `targets`                   | array         | 目标提供商配置列表     | 每个元素必须有 `provider`；支持嵌套                         | [{"provider": "openai", "weight": 1}]                       |
| `targets[].provider`        | string        | AI 提供商名称          | 必须在白名单中                                              | "openai"                                                    |
| `targets[].weight`          | number        | 负载均衡权重           | 默认 1；用于随机选择                                        | 0.75                                                        |
| `targets[].override_params` | object        | 覆盖参数（如 api_key） | 可选；用于提供商特定设置                                    | {"api_key": "sk-..."}                                       |
| `retry.attempts`            | number        | 最大重试次数           | 范围 1–5；默认 0（禁用）                                    | 3                                                           |
| `retry.on_status_codes`     | array<number> | 触发重试的状态码       | 默认 [429, 500, 502, 503]                                   | [429, 502]                                                  |
| `request_timeout`           | number        | 请求超时（ms）         | 可选                                                        | 30000                                                       |
| `cache.mode`                | string        | 缓存模式               | "simple"（开源版支持）；"semantic"（企业版）                | "simple"                                                    |
| `before_request_hooks`      | array<object> | 输入验证钩子           | 每个对象指定插件（如 "regexMatch"）                         | [{"plugin": "modelWhitelist", "allowed_models": ["gpt-4"]}] |
| `after_request_hooks`       | array<object> | 输出验证钩子           | 类似 before hooks                                           | [{"plugin": "jsonSchema", "schema": {...}}]                 |
| `metadata`                  | object        | 自定义元数据           | 用于追踪或条件路由                                          | {"user_id": "123"}                                          |

#### 示例完整配置（符合 schema）：
```json
{
  "strategy": { "mode": "fallback" },
  "targets": [
    { "provider": "openai", "override_params": { "api_key": "sk-..." } },
    { "provider": "anthropic", "override_params": { "api_key": "sk-..." } }
  ],
  "retry": { "attempts": 3, "on_status_codes": [429, 502] },
  "cache": { "mode": "simple" },
  "before_request_hooks": [{ "plugin": "modelWhitelist", "allowed_models": ["gpt-4"] }],
  "after_request_hooks": [{ "plugin": "jsonSchema", "schema": { "type": "object", "properties": { "answer": { "type": "string" } } } }],
  "metadata": { "env": "prod" }
}
```

如果配置无效（如 mode 不是枚举值），Gateway 会返回错误，通常是 400 Bad Request 或类似。

- **开源版局限**：semantic 缓存或高级 schema 特性（如动态 schema）是企业版独有；开源版保持简单。
- **来源和调试**：这些规则来自 GitHub 仓库的 `requestValidator.ts`、`plugins/` 和 README。如果实现时出错，检查日志（设置 `LOG_LEVEL=debug`）或查看源代码。

## valid providers

```js
export const OPEN_AI: string = 'openai';
export const COHERE: string = 'cohere';
export const AZURE_OPEN_AI: string = 'azure-openai';
export const AZURE_AI_INFERENCE: string = 'azure-ai';
export const ANTHROPIC: string = 'anthropic';
export const ANYSCALE: string = 'anyscale';
export const PALM: string = 'palm';
export const TOGETHER_AI: string = 'together-ai';
export const GOOGLE: string = 'google';
export const GOOGLE_VERTEX_AI: string = 'vertex-ai';
export const HUGGING_FACE: string = 'huggingface';
export const PERPLEXITY_AI: string = 'perplexity-ai';
export const REKA_AI: string = 'reka-ai';
export const MISTRAL_AI: string = 'mistral-ai';
export const DEEPINFRA: string = 'deepinfra';
export const NCOMPASS: string = 'ncompass';
export const STABILITY_AI: string = 'stability-ai';
export const NOMIC: string = 'nomic';
export const OLLAMA: string = 'ollama';
export const AI21: string = 'ai21';
export const BEDROCK: string = 'bedrock';
export const GROQ: string = 'groq';
export const SEGMIND: string = 'segmind';
export const JINA: string = 'jina';
export const FIREWORKS_AI: string = 'fireworks-ai';
export const WORKERS_AI: string = 'workers-ai';
export const MOONSHOT: string = 'moonshot';
export const OPENROUTER: string = 'openrouter';
export const LINGYI: string = 'lingyi';
export const ZHIPU: string = 'zhipu';
export const NOVITA_AI: string = 'novita-ai';
export const MONSTERAPI: string = 'monsterapi';
export const DEEPSEEK: string = 'deepseek';
export const PREDIBASE: string = 'predibase';
export const TRITON: string = 'triton';
export const VOYAGE: string = 'voyage';
export const GITHUB: string = 'github';
export const DEEPBRICKS: string = 'deepbricks';
export const SILICONFLOW: string = 'siliconflow';
export const CEREBRAS: string = 'cerebras';
export const INFERENCENET: string = 'inference-net';
export const SAMBANOVA: string = 'sambanova';
export const LEMONFOX_AI: string = 'lemonfox-ai';
export const UPSTAGE: string = 'upstage';
export const LAMBDA: string = 'lambda';
export const DASHSCOPE: string = 'dashscope';
export const X_AI: string = 'x-ai';
export const CORTEX: string = 'cortex';
export const SAGEMAKER: string = 'sagemaker';
export const NEBIUS: string = 'nebius';
export const RECRAFTAI: string = 'recraft-ai';
export const MILVUS: string = 'milvus';
export const REPLICATE: string = 'replicate';
export const LEPTON: string = 'lepton';
export const KLUSTER_AI: string = 'kluster-ai';
export const NSCALE: string = 'nscale';
export const HYPERBOLIC: string = 'hyperbolic';
export const BYTEZ: string = 'bytez';
export const FEATHERLESS_AI: string = 'featherless-ai';
export const KRUTRIM: string = 'krutrim';
export const QDRANT: string = 'qdrant';
export const THREE_ZERO_TWO_AI: string = '302ai';
export const COMETAPI: string = 'cometapi';
export const MATTERAI: string = 'matterai';
export const MESHY: string = 'meshy';
export const TRIPO3D: string = 'tripo3d';
export const NEXTBIT: string = 'nextbit';
export const MODAL: string = 'modal';
export const Z_AI: string = 'z-ai';
```

## 用量信息

是的，您需要解析响应体（response body）来获取用量信息。Portkey Gateway会将各个provider的用量字段统一转换为标准格式。 [1](#3-0) 

### 统一的用量字段结构

所有provider的响应都会被转换为标准的`usage`结构 [2](#3-1) ：

```typescript
usage: {
  prompt_tokens: number;           // 输入token数
  completion_tokens: number;       // 输出token数  
  total_tokens: number;            // 总token数
  completion_tokens_details?: {    // 可选的输出详情
    reasoning_tokens?: number;
    audio_tokens?: number;
  };
  prompt_tokens_details?: {        // 可选的输入详情
    cached_tokens?: number;
    audio_tokens?: number;
  };
  // Anthropic缓存相关
  cache_read_input_tokens?: number;
  cache_creation_input_tokens?: number;
}
```

### Provider转换示例

不同provider的原始响应会被统一转换：

**Anthropic** - 从`input_tokens/output_tokens`转换 [3](#3-2) ：
```typescript
usage: {
  prompt_tokens: parsedChunk.message?.usage?.input_tokens,
  completion_tokens: parsedChunk.usage?.output_tokens,
  total_tokens: totalTokens,
}
```

**Google Vertex AI** - 从`promptTokenCount/candidatesTokenCount`转换 [4](#3-3) ：
```typescript
usageMetadata = {
  prompt_tokens: parsedChunk.usageMetadata.promptTokenCount,
  completion_tokens: parsedChunk.usageMetadata.candidatesTokenCount,
  total_tokens: parsedChunk.usageMetadata.totalTokenCount,
}
```

**DeepSeek** - 已经是标准格式，直接映射 [5](#3-4) ：
```typescript
usage: {
  prompt_tokens: response.usage?.prompt_tokens,
  completion_tokens: response.usage?.completion_tokens,
  total_tokens: response.usage?.total_tokens,
}
```

### 获取用量信息的代码

```javascript
const result = await response.json();
const usage = result.usage;

console.log('用量信息:', {
  prompt_tokens: usage.prompt_tokens,
  completion_tokens: usage.completion_tokens,
  total_tokens: usage.total_tokens,
  cached_tokens: usage.prompt_tokens_details?.cached_tokens || 0
});
```

## Notes

1. **字段统一性**：经过Gateway转换后，所有provider的用量字段都遵循`CResponse`接口定义 [6](#3-5) ，确保客户端代码的一致性。

2. **特殊字段**：某些provider特有的字段（如Anthropic的缓存token、Google的reasoning token）会被保留在`_details`字段中 [7](#3-6) 。

3. **流式响应**：在流式响应中，usage信息可能在最后的chunk中返回 [8](#3-7) 。

4. **缺失处理**：如果provider不提供某些信息，对应字段会设为0或undefined [9](#3-8) 。

## 答案

是的，这些响应头信息非常有用，可以用于多种场景。Portkey Gateway的设计就是为了让这些元数据能够被客户端和中间件利用。 [1](#4-0) 

### 主要利用场景

#### 1. 监控和可观测性
- **性能监控**：`req-cost-time`、`x-envoy-upstream-service-time` 可用于分析请求延迟
- **缓存效果**：`x-portkey-cache-status` 监控缓存命中率
- **重试统计**：`x-portkey-retry-attempt-count` 跟踪系统稳定性

#### 2. 调试和故障排查
- **请求追踪**：`x-portkey-trace-id` 用于分布式追踪，关联多个服务调用 [2](#4-1) 
- **配置路径**：`x-portkey-last-used-option-index` 帮助定位使用了哪个配置目标
- **提供商识别**：`x-portkey-provider` 快速识别实际调用的AI服务

#### 3. 业务统计和成本分析
```javascript
// 示例：利用响应头进行统计
const stats = {
  provider: response.headers.get('x-portkey-provider'),
  cacheHit: response.headers.get('x-portkey-cache-status') !== 'DISABLED',
  retryCount: parseInt(response.headers.get('x-portkey-retry-attempt-count')),
  latency: parseInt(response.headers.get('req-cost-time')),
  configPath: response.headers.get('x-portkey-last-used-option-index')
};

// 发送到监控系统或写入日志
analytics.track('api_request', stats);
```

#### 4. 插件系统集成
插件系统可以利用这些头部信息：
- **安全插件**：使用 `x-portkey-trace-id` 进行安全审计追踪 [3](#4-2) 
- **日志插件**：记录完整的请求上下文信息 [4](#4-3) 

#### 5. 动态路由决策
基于响应头信息可以做出实时决策：
```javascript
// 根据缓存状态调整策略
if (response.headers.get('x-portkey-cache-status') === 'DISABLED') {
  // 启用缓存或调整配置
}

// 根据重试次数判断提供商健康度
const retryCount = parseInt(response.headers.get('x-portkey-retry-attempt-count'));
if (retryCount > 2) {
  // 标记提供商为不健康，切换到备用提供商
}
```

## Notes

1. **性能考虑**：响应头信息轻量且实时，无需解析响应体即可获取关键指标
2. **标准化**：所有 `x-portkey-` 前缀的头部在 `RESPONSE_HEADER_KEYS` 中统一定义 [5](#4-4) 
3. **扩展性**：插件系统可以访问完整的请求上下文，包括这些响应头信息
4. **日志集成**：`LogsService` 会自动收集这些信息用于请求日志记录 [4](#4-3) 

这些响应头设计为可被客户端、监控系统和插件充分利用，是Gateway可观测性架构的重要组成部分。

