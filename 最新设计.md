# portkey gateway çš„ x-portkey-config è¯¦è§£

## ä¸»è¦é…ç½®

| å±æ€§                        | ç±»å‹          | æè¿°                   | çº¦æŸ/é»˜è®¤å€¼                                                 | ç¤ºä¾‹                                                        |
| --------------------------- | ------------- | ---------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |
| `strategy.mode`             | string        | è·¯ç”±ç­–ç•¥æ¨¡å¼           | å¿…é¡»æ˜¯ "loadbalance"ã€"fallback"ã€"conditional" æˆ– "single" | "loadbalance"                                               |
| `targets`                   | array         | ç›®æ ‡æä¾›å•†é…ç½®åˆ—è¡¨     | æ¯ä¸ªå…ƒç´ å¿…é¡»æœ‰ `provider`ï¼›æ”¯æŒåµŒå¥—                         | [{"provider": "openai", "weight": 1}]                       |
| `targets[].provider`        | string        | AI æä¾›å•†åç§°          | å¿…é¡»åœ¨ç™½åå•ä¸­                                              | "openai"                                                    |
| `targets[].weight`          | number        | è´Ÿè½½å‡è¡¡æƒé‡           | é»˜è®¤ 1ï¼›ç”¨äºéšæœºé€‰æ‹©                                        | 0.75                                                        |
| `targets[].override_params` | object        | è¦†ç›–å‚æ•°ï¼ˆå¦‚ api_keyï¼‰ | å¯é€‰ï¼›ç”¨äºæä¾›å•†ç‰¹å®šè®¾ç½®                                    | {"api_key": "sk-..."}                                       |
| `retry.attempts`            | number        | æœ€å¤§é‡è¯•æ¬¡æ•°           | èŒƒå›´ 1â€“5ï¼›é»˜è®¤ 0ï¼ˆç¦ç”¨ï¼‰                                    | 3                                                           |
| `retry.on_status_codes`     | array<number> | è§¦å‘é‡è¯•çš„çŠ¶æ€ç        | é»˜è®¤ [429, 500, 502, 503]                                   | [429, 502]                                                  |
| `request_timeout`           | number        | è¯·æ±‚è¶…æ—¶ï¼ˆmsï¼‰         | å¯é€‰                                                        | 30000                                                       |
| `cache.mode`                | string        | ç¼“å­˜æ¨¡å¼               | "simple"ï¼ˆå¼€æºç‰ˆæ”¯æŒï¼‰ï¼›"semantic"ï¼ˆä¼ä¸šç‰ˆï¼‰                | "simple"                                                    |
| `before_request_hooks`      | array<object> | è¾“å…¥éªŒè¯é’©å­           | æ¯ä¸ªå¯¹è±¡æŒ‡å®šæ’ä»¶ï¼ˆå¦‚ "regexMatch"ï¼‰                         | [{"plugin": "modelWhitelist", "allowed_models": ["gpt-4"]}] |
| `after_request_hooks`       | array<object> | è¾“å‡ºéªŒè¯é’©å­           | ç±»ä¼¼ before hooks                                           | [{"plugin": "jsonSchema", "schema": {...}}]                 |
| `metadata`                  | object        | è‡ªå®šä¹‰å…ƒæ•°æ®           | ç”¨äºè¿½è¸ªæˆ–æ¡ä»¶è·¯ç”±                                          | {"user_id": "123"}                                          |

## è¡¥å……çš„é…ç½®

| å±æ€§                        | ç±»å‹    | æè¿°                    | çº¦æŸ/é»˜è®¤å€¼                  | ç¤ºä¾‹                                                |
| --------------------------- | ------- | ----------------------- | ---------------------------- | --------------------------------------------------- |
| `strategy.on_status_codes`  | array   | ç­–ç•¥çº§è§¦å‘çŠ¶æ€ç         | å¯é€‰                         | [429, 500, 502]                                     |
| `strategy.conditions`       | array   | æ¡ä»¶è·¯ç”±è§„åˆ™            | ä»… conditional æ¨¡å¼          | [{"query": {}, "then": "target"}]                   |
| `strategy.default`          | string  | æ¡ä»¶è·¯ç”±é»˜è®¤ç›®æ ‡        | ä»… conditional æ¨¡å¼          | "fallback-target"                                   |
| `api_key`                   | string  | API å¯†é’¥                | ä¸ provider é…åˆä½¿ç”¨         | "sk-..."                                            |
| `weight`                    | number  | æ ¹çº§æƒé‡                | é»˜è®¤ 1                       | 0.5                                                 |
| `on_status_codes`           | array   | æ ¹çº§è§¦å‘çŠ¶æ€ç           | é»˜è®¤ [429, 500, 502, 503]    | [429, 502]                                          |
| `custom_host`               | string  | è‡ªå®šä¹‰ API ä¸»æœº         | å¯é€‰ï¼›ä¸èƒ½åŒ…å« 'api.portkey' | "[https://api.custom.com](https://api.custom.com/)" |
| `forward_headers`           | array   | è½¬å‘å¤´éƒ¨åˆ—è¡¨            | å¯é€‰                         | ["x-user-id", "x-org"]                              |
| `strict_open_ai_compliance` | boolean | OpenAI å“åº”æ ¼å¼ä¸¥æ ¼æ¨¡å¼ | é»˜è®¤ true                    | false                                               |
| `virtual_key`               | string  | è™šæ‹Ÿå¯†é’¥æ ‡è¯†            | å¯é€‰                         | "vk_..."                                            |

## æä¾›å•†ç‰¹å®šå­—æ®µ

| å±æ€§                                                       | ç±»å‹   | æè¿°                  | é€‚ç”¨æä¾›å•†         |
| ---------------------------------------------------------- | ------ | --------------------- | ------------------ |
| `aws_access_key_id`, `aws_secret_access_key`, `aws_region` | string | AWS è®¤è¯ä¿¡æ¯          | bedrock, sagemaker |
| `vertex_project_id`, `vertex_region`                       | string | Vertex AI é¡¹ç›®å’ŒåŒºåŸŸ  | vertex-ai          |
| `vertex_service_account_json`                              | object | Vertex AI æœåŠ¡è´¦æˆ·    | vertex-ai          |
| `resource_name`, `deployment_id`, `api_version`            | string | Azure OpenAI èµ„æºä¿¡æ¯ | azure-openai       |
| `openai_organization`, `openai_project`                    | string | OpenAI ç»„ç»‡å’Œé¡¹ç›®     | openai             |
| `anthropic_beta`, `anthropic_version`                      | string | Anthropic ç‰¹å®šå‚æ•°    | anthropic          |

## api_key çš„ä½œç”¨

`api_key` å…è®¸åœ¨é…ç½®ä¸­ç›´æ¥æŒ‡å®šæä¾›å•†çš„ API å¯†é’¥ï¼Œæ— éœ€é€šè¿‡ Authorization header ä¼ é€’ requestBody.ts:50-51 ï¼š

```
{  
  "provider": "openai",  
  "api_key": "sk-..."  
}
```

åœ¨é…ç½®æ„é€ è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ²¡æœ‰æä¾› Authorization headerï¼Œç³»ç»Ÿä¼šä½¿ç”¨é…ç½®ä¸­çš„ `api_key` 

## overrideParams

`overrideParams` å¯ä»¥è¦†ç›–å‡ ä¹æ‰€æœ‰ AI è¯·æ±‚å‚æ•°ï¼Œä¸ä»…ä»…æ˜¯ `model`ã€‚

### å¯è¦†ç›–çš„å‚æ•°ç±»å‹

æ ¹æ® `Params` æ¥å£å®šä¹‰ï¼Œ`overrideParams` å¯ä»¥è¦†ç›–ä»¥ä¸‹å‚æ•°ï¼š

#### åŸºç¡€æ¨¡å‹å‚æ•°

- `model` - æ¨¡å‹åç§°
- `messages` - å¯¹è¯æ¶ˆæ¯æ•°ç»„
- `prompt` - æç¤ºæ–‡æœ¬
- `max_tokens` / `max_completion_tokens` - æœ€å¤§ç”Ÿæˆä»¤ç‰Œæ•°
- `temperature` - éšæœºæ€§æ§åˆ¶ (0-2)
- `top_p` - æ ¸é‡‡æ ·å‚æ•° (0-1)
- `top_k` - é‡‡æ ·å€™é€‰æ•°é‡
- `stream` - æ˜¯å¦æµå¼å“åº”

#### é«˜çº§æ§åˆ¶å‚æ•°

- `stop` - åœæ­¢è¯/åœæ­¢åºåˆ—
- `presence_penalty` - å­˜åœ¨æƒ©ç½š (-2 åˆ° 2)
- `frequency_penalty` - é¢‘ç‡æƒ©ç½š (-2 åˆ° 2)
- `seed` - éšæœºç§å­
- `user` - ç”¨æˆ·æ ‡è¯†
- `n` - ç”Ÿæˆå€™é€‰æ•°é‡

#### å·¥å…·å’Œå‡½æ•°è°ƒç”¨

- `tools` - å·¥å…·å®šä¹‰æ•°ç»„
- `tool_choice` - å·¥å…·é€‰æ‹©ç­–ç•¥
- `functions` - å‡½æ•°å®šä¹‰ï¼ˆå·²å¼ƒç”¨ï¼‰
- `function_call` - å‡½æ•°è°ƒç”¨ç­–ç•¥ï¼ˆå·²å¼ƒç”¨ï¼‰

#### ç‰¹æ®Šæ ¼å¼å‚æ•°

- `response_format` - å“åº”æ ¼å¼ï¼ˆJSON/æ–‡æœ¬ï¼‰
- `logprobs` - å¯¹æ•°æ¦‚ç‡
- `top_logprobs` - é¡¶éƒ¨å¯¹æ•°æ¦‚ç‡
- `echo` - æ˜¯å¦å›æ˜¾è¾“å…¥

#### æä¾›å•†ç‰¹å®šå‚æ•°

- `safety_settings` - Google å®‰å…¨è®¾ç½®
- `anthropic_beta` - Anthropic Beta åŠŸèƒ½
- `anthropic_version` - Anthropic ç‰ˆæœ¬
- `thinking` - Anthropic æ€è€ƒæ¨¡å¼
- `dimensions` - åµŒå…¥ç»´åº¦
- `audio` - éŸ³é¢‘å‚æ•° [1](#8-0) 

### å®é™…é…ç½®ç¤ºä¾‹

#### 1. åŸºç¡€å‚æ•°è¦†ç›–

```json
{
  "x-portkey-config": {
    "strategy": { "mode": "loadbalance" },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {
          "model": "gpt-4",
          "temperature": 0.7,
          "max_tokens": 2000,
          "presence_penalty": 0.1,
          "frequency_penalty": 0.1
        },
        "weight": 0.6
      },
      {
        "provider": "anthropic",
        "overrideParams": {
          "model": "claude-3-sonnet",
          "temperature": 0.5,
          "max_tokens": 4000,
          "anthropic_version": "2023-06-01"
        },
        "weight": 0.4
      }
    ]
  }
}
```

#### 2. å·¥å…·è°ƒç”¨è¦†ç›–

```json
{
  "x-portkey-config": {
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {
          "model": "gpt-4",
          "tools": [
            {
              "type": "function",
              "function": {
                "name": "get_weather",
                "description": "Get weather information",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "location": { "type": "string" }
                  }
                }
              }
            }
          ],
          "tool_choice": "auto"
        }
      }
    ]
  }
}
```

#### 3. å“åº”æ ¼å¼è¦†ç›–

```json
{
  "x-portkey-config": {
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {
          "model": "gpt-4",
          "response_format": {
            "type": "json_schema",
            "json_schema": {
              "name": "weather_response",
              "schema": {
                "type": "object",
                "properties": {
                  "temperature": { "type": "number" },
                  "conditions": { "type": "string" }
                }
              }
            }
          }
        }
      }
    ]
  }
}
```

#### 4. æä¾›å•†ç‰¹å®šå‚æ•°

```json
{
  "x-portkey-config": {
    "targets": [
      {
        "provider": "google-vertex-ai",
        "overrideParams": {
          "model": "gemini-pro",
          "safety_settings": [
            {
              "category": "HARM_CATEGORY_HARASSMENT",
              "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        }
      },
      {
        "provider": "anthropic",
        "overrideParams": {
          "model": "claude-3-sonnet",
          "anthropic_beta": ["tools-2024-04-04"],
          "thinking": {
            "type": "enabled",
            "budget_tokens": 5000
          }
        }
      }
    ]
  }
}
```

## targets

- **Targets = Destinations**: They define where your requests go
- **Recursive**: Targets can contain other targets, creating routing trees
- **Inheritance**: Parent target settings flow down to child targets handlerUtils.ts:488-642
- **Strategy-driven**: The `strategy.mode` determines how to pick between targets

"targets" are essentially what your configuration "applies to" - they're the providers and routing paths that will handle your requests.

**Targets always eventually resolve to an AI provider** - the nested structure is just for routing decisions. The actual API call is made to the provider specified in the leaf target.

ä»¥ä¸‹æ˜¯ JSON æ ¼å¼çš„é…ç½®ç¤ºä¾‹ï¼š

### 1. loadbalance æ¨¡å¼ç¤ºä¾‹

```json
{  
  "x-portkey-config": {  
    "strategy": {  
      "mode": "loadbalance"  
    },  
    "targets": [  
      {  
        "provider": "openai",  
        "overrideParams": { "model": "gpt-4" },  
        "weight": 60  
      },  
      {  
        "provider": "anthropic",  
        "overrideParams": { "model": "claude-3-sonnet" },  
        "weight": 40  
      }  
    ]  
  }  
}
```

**å¤„ç†æ–¹å¼**ï¼šæ¯10ä¸ªè¯·æ±‚ä¸­ï¼Œå¤§çº¦6ä¸ªä¼šå‘ç»™GPT-4ï¼Œ4ä¸ªå‘ç»™Claude-3ï¼Œå®ç°æµé‡åˆ†å‘ã€‚

### 2. fallback æ¨¡å¼ç¤ºä¾‹

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "fallback"
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-4"},
      },
      {
        "provider": "anthropic",
        "overrideParams": {"model": "claude-3-sonnet"},
      },
      {
        "provider": "azure-openai", 
        "overrideParams": {"model": "gpt-35-turbo"}
      }
    ]
  }
}
```

**å®é™…åœºæ™¯**ï¼šå½“OpenAI APIå‡ºç°æ•…éšœæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°è¯•Anthropicï¼Œå†ä¸æˆåŠŸåˆ™ç”¨Azureï¼Œç¡®ä¿æœåŠ¡ä¸ä¸­æ–­ã€‚**ä¾èµ–æ•°ç»„é¡ºåº** - æŒ‰ targets æ•°ç»„ä¸­çš„é¡ºåºè¿›è¡Œæ•…éšœè½¬ç§»

### 3. conditional æ¨¡å¼ç¤ºä¾‹ï¼ˆä¸metaååŒï¼‰

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "conditional"
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-4"},
        "meta": {
          "condition": "${request.messages.length < 5}"
        }
      },
      {
        "provider": "anthropic",
        "overrideParams": {"model": "claude-3-sonnet"},
        "meta": {
          "condition": "${request.messages.length >= 5}"
        }
      },
      {
        "provider": "openai", 
        "overrideParams": {"model": "gpt-4-vision"},
        "meta": {
          "condition": "${request.messages[0].containsImage}"
        }
      }
    ]
  }
}
```

**å¤„ç†æœºåˆ¶**ï¼šæ ¹æ®æ¶ˆæ¯é•¿åº¦å’Œå†…å®¹ç±»å‹æ™ºèƒ½é€‰æ‹©æœ€åˆé€‚çš„æ¨¡å‹ã€‚æŒ‰æ•°ç»„é¡ºåºè¯„ä¼°æ¡ä»¶ï¼Œç¬¬ä¸€ä¸ªåŒ¹é…çš„æ¡ä»¶ç”Ÿæ•ˆ.

### 4. single æ¨¡å¼ç¤ºä¾‹

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "single"
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-3.5-turbo"}
      }
    ]
  }
}
```

**å«ä¹‰**ï¼šæ‰€æœ‰è¯·æ±‚éƒ½å›ºå®šå‘é€åˆ°GPT-3.5-Turboï¼Œæ²¡æœ‰å¤‡é€‰æ–¹æ¡ˆï¼Œé€‚åˆç®€å•åº”ç”¨æˆ–æµ‹è¯•ç¯å¢ƒã€‚

**å…³é”®ç‚¹**ï¼š

- `targets` æ˜¯æ•°ç»„ï¼Œä¿æŒå…ƒç´ é¡ºåº
- `fallback` æ¨¡å¼ä¾èµ–æ•°ç»„é¡ºåºå†³å®šæ•…éšœè½¬ç§»ä¼˜å…ˆçº§
- `loadbalance` ä½¿ç”¨ `weight` å­—æ®µæ§åˆ¶æ¯”ä¾‹
- `conditional` æŒ‰æ•°ç»„é¡ºåºè¯„ä¼°æ¡ä»¶
- `single` ä½¿ç”¨æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ 

## retry

`retry.on_status_codes` ç”¨äºæŒ‡å®šåœ¨é‡åˆ°å“ªäº›HTTPçŠ¶æ€ç æ—¶è¿›è¡Œé‡è¯•ã€‚ä»¥ä¸‹æ˜¯å…·ä½“çš„ç”¨æ³•ç¤ºä¾‹ï¼š

### 1. é‡è¯•æœåŠ¡å™¨é”™è¯¯ (5xx)

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "single",
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-4"},
      }
    ],
    "retry": {
      "attempts": 3,
      "on_status_codes": [500, 502, 503, 504]
    }
  }
}
```

**åœºæ™¯**ï¼šå½“é‡åˆ°æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ã€ç½‘å…³é”™è¯¯ã€æœåŠ¡ä¸å¯ç”¨æˆ–ç½‘å…³è¶…æ—¶æ—¶ï¼Œè‡ªåŠ¨é‡è¯•3æ¬¡ã€‚

### 2. é‡è¯•é™æµé”™è¯¯ (429)

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "fallback"
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-4"},
      },
      {
        "provider": "anthropic",
        "overrideParams": {"model": "claude-3-sonnet"}
      }
    ],
    "retry": {
      "attempts": 2,
      "on_status_codes": [429],
    }
  }
}
```

**åœºæ™¯**ï¼šå½“APIè¿”å›429ï¼ˆè¯·æ±‚è¿‡å¤šï¼‰æ—¶ï¼Œå…ˆé‡è¯•2æ¬¡ï¼Œå¦‚æœä»ç„¶å¤±è´¥åˆ™åˆ‡æ¢åˆ°å¤‡ç”¨æä¾›å•†ã€‚

### 3. æ··åˆé”™è¯¯é‡è¯•ç­–ç•¥

```json
{  
  "x-portkey-config": {  
    "strategy": {    
      "mode": "loadbalance"    
    },    
    "retry": {  
      "attempts": 3,  
      "on_status_codes": [429, 500, 502, 503]  
    },  
    "targets": [    
      {    
        "provider": "openai",    
        "overrideParams": { "model": "gpt-4" },    
        "weight": 40    
      },    
      {    
        "provider": "openai",     
        "overrideParams": { "model": "gpt-3.5-turbo" },    
        "weight": 30    
      },    
      {    
        "provider": "anthropic",    
        "overrideParams": { "model": "claude-3-sonnet" },    
        "weight": 30    
      }    
    ]    
  }  
}

```

**åœºæ™¯**ï¼šå¯¹é™æµé”™è¯¯å’ŒæœåŠ¡å™¨é”™è¯¯éƒ½è¿›è¡Œé‡è¯•.

### 4. å®¢æˆ·ç«¯é”™è¯¯é€‰æ‹©æ€§é‡è¯•

```json
{
  "x-portkey-config": {
    "strategy": {
      "mode": "single"
    },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": {"model": "gpt-4"}
      }
    ],
    "retry": {
      "attempts": 1,
      "on_status_codes": [408, 429]
    }
  }
}
```

**åœºæ™¯**ï¼šåªå¯¹è¯·æ±‚è¶…æ—¶(408)å’Œé™æµ(429)è¿›è¡Œé‡è¯•ï¼Œå…¶ä»–4xxé”™è¯¯ï¼ˆå¦‚400ã€401ï¼‰ä¸é‡è¯•ã€‚

### å®é™…å·¥ä½œæµç¨‹ç¤ºä¾‹

```json
{
  "x-portkey-config": {
    "retry": {
      "attempts": 3,
      "on_status_codes": [429, 500, 502, 503]
    }
  }
}
```

**æ‰§è¡Œè¿‡ç¨‹**ï¼š

1. é¦–æ¬¡è¯·æ±‚ â†’ è¿”å› `429 Too Many Requests`
2. ç¬¬1æ¬¡é‡è¯•ï¼ˆç­‰å¾…åï¼‰â†’ è¿”å› `502 Bad Gateway`  
3. ç¬¬2æ¬¡é‡è¯•ï¼ˆç­‰å¾…åï¼‰â†’ è¿”å› `200 OK` âœ…
4. é‡è¯•æˆåŠŸï¼Œæµç¨‹ç»“æŸ

**é‡è¦è¯´æ˜**ï¼š

- `on_status_codes` æ•°ç»„æ˜ç¡®æŒ‡å®šäº†å“ªäº›çŠ¶æ€ç è§¦å‘é‡è¯•æœºåˆ¶
- å¯¹äº4xxé”™è¯¯ï¼Œé€šå¸¸åªé‡è¯•`429`ï¼ˆé™æµï¼‰å’Œ`408`ï¼ˆè¶…æ—¶ï¼‰
- å¯¹äº5xxé”™è¯¯ï¼Œé€šå¸¸éƒ½ä¼šé‡è¯•ï¼Œå› ä¸ºè¿™æ˜¯æœåŠ¡å™¨ç«¯é—®é¢˜

## strategy.loadbalance è´Ÿè½½å‡è¡¡çš„ç²’åº¦

åœ¨ `loadbalance` æ¨¡å¼ä¸‹ï¼Œæ¯ä¸ª `target` éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è´Ÿè½½å‡è¡¡å•å…ƒï¼Œå¯ä»¥åŒ…å«ï¼š

- ä¸åŒçš„ `provider`
- ä¸åŒçš„ `model`ï¼ˆé€šè¿‡ `overrideParams` æŒ‡å®šï¼‰
- ä¸åŒçš„æƒé‡ `weight`

### å®é™…é…ç½®ç¤ºä¾‹

#### ä¸åŒ Provider + ä¸åŒ Model

```json
{
  "strategy": { "mode": "loadbalance" },
  "targets": [
    {
      "provider": "openai",
      "weight": 0.7,
      "overrideParams": { "model": "gpt-4" }
    },
    {
      "provider": "anthropic", 
      "weight": 0.3,
      "overrideParams": { "model": "claude-3-opus-20240229" }
    }
  ]
}
```

#### åŒä¸€ Provider + ä¸åŒ Model

```json
{
  "strategy": { "mode": "loadbalance" },
  "targets": [
    {
      "provider": "openai",
      "weight": 0.5,
      "overrideParams": { "model": "gpt-4" }
    },
    {
      "provider": "openai",
      "weight": 0.5, 
      "overrideParams": { "model": "gpt-3.5-turbo" }
    }
  ]
}
```

## é…ç½®ç»§æ‰¿çš„ä¸¤ä¸ªå±‚é¢

### 1. ä¼˜å…ˆçº§å±‚é¢ï¼šå­ç›®æ ‡è¦†ç›–çˆ¶ç›®æ ‡

åœ¨æ‰§è¡Œæ—¶ï¼Œå¦‚æœå­ç›®æ ‡å®šä¹‰äº†æŸä¸ªé…ç½®ï¼Œä¼šä¼˜å…ˆä½¿ç”¨å­ç›®æ ‡çš„é…ç½®ï¼š

```
// å­ç›®æ ‡æœ‰ retry æ—¶ï¼Œä½¿ç”¨å­ç›®æ ‡çš„ retry  
retry: currentTarget.retry  
  ? { ...currentTarget.retry }      // å­ç›®æ ‡é…ç½®  
  : { ...inheritedConfig.retry },   // çˆ¶ç›®æ ‡é…ç½®
```

handlerUtils.ts:495-500

### 2. ä¼ é€’æ–¹å‘å±‚é¢ï¼šå•å‘ä»çˆ¶åˆ°å­

é…ç½®åªèƒ½ä»çˆ¶ç›®æ ‡ä¼ é€’ç»™å­ç›®æ ‡ï¼Œå­ç›®æ ‡çš„é…ç½®å˜åŒ–ä¸ä¼šåå‘å½±å“çˆ¶ç›®æ ‡

### å®é™…ä¾‹å­

```
{  
  "retry": { "attempts": 5 },        // çˆ¶ç›®æ ‡é…ç½®  
  "targets": [  
    {  
      "retry": { "attempts": 2 },    // å­ç›®æ ‡é…ç½®ï¼ˆè¦†ç›–çˆ¶çº§ï¼‰  
      "provider": "openai"  
    },  
    {  
      "provider": "anthropic"        // ä½¿ç”¨çˆ¶çº§é…ç½®ï¼ˆattempts: 5ï¼‰  
    }  
  ]  
}
```

### æ€»ç»“

- **è¦†ç›–å…³ç³»**ï¼šå­ç›®æ ‡é…ç½®ä¼˜å…ˆçº§æ›´é«˜ï¼Œä¼š"è¦†ç›–"çˆ¶ç›®æ ‡çš„åŒåé…ç½®
- **ç»§æ‰¿æ–¹å‘**ï¼šé…ç½®åªèƒ½ä»çˆ¶æµå‘å­ï¼Œæ˜¯å•å‘çš„ï¼Œå­ä¸èƒ½å½±å“çˆ¶

è¿™å°±åƒ CSS æ ·å¼ç»§æ‰¿ï¼šå­å…ƒç´ å¯ä»¥è¦†ç›–çˆ¶å…ƒç´ çš„æ ·å¼ï¼Œä½†å­å…ƒç´ çš„æ ·å¼å˜åŒ–ä¸ä¼šå½±å“çˆ¶å…ƒç´ ã€‚ handlerUtils.ts:488-504

## é…ç½®ç»§æ‰¿ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ Portkey Gateway ä¸­é…ç½®ç»§æ‰¿çš„å®é™…åº”ç”¨ç¤ºä¾‹ï¼š

### 1. é‡è¯•é…ç½®ç»§æ‰¿

```json
{
  "x-portkey-config": {
    "retry": { "attempts": 5 },           // çˆ¶çº§ï¼šé»˜è®¤é‡è¯•5æ¬¡
    "strategy": { "mode": "fallback" },
    "targets": [
      {
        "name": "OpenAI é›†ç¾¤",
        "retry": { "attempts": 2 },        // å­çº§ï¼šè¦†ç›–ä¸º2æ¬¡
        "targets": [
          { "provider": "openai" },        // ç»§æ‰¿ï¼š2æ¬¡é‡è¯•
          { "provider": "openai" }         // ç»§æ‰¿ï¼š2æ¬¡é‡è¯•
        ]
      },
      {
        "name": "Anthropic å¤‡ç”¨",
        "provider": "anthropic"            // ç»§æ‰¿ï¼š5æ¬¡é‡è¯•
      }
    ]
  }
}
```

### 2. ç¼“å­˜é…ç½®ç»§æ‰¿

```json
{
  "x-portkey-config": {
    "cache": { 
      "mode": "simple", 
      "max_age": 3600 
    },                                   // çˆ¶çº§ï¼šç¼“å­˜1å°æ—¶
    "strategy": { "mode": "loadbalance" },
    "targets": [
      {
        "provider": "openai",
        "weight": 0.6                     // ç»§æ‰¿ï¼šç¼“å­˜1å°æ—¶
      },
      {
        "provider": "anthropic",
        "cache": { "max_age": 1800 },     // å­çº§ï¼šè¦†ç›–ä¸º30åˆ†é’Ÿ
        "weight": 0.4
      }
    ]
  }
}
```

### 3. overrideParams æ·±åº¦åˆå¹¶

```json
{
  "x-portkey-config": {
    "overrideParams": { 
      "temperature": 0.7,
      "max_tokens": 1000
    },                                   // çˆ¶çº§å‚æ•°
    "strategy": { "mode": "fallback" },
    "targets": [
      {
        "provider": "openai",
        "overrideParams": { 
          "model": "gpt-4",
          "temperature": 0.9             // å­çº§ï¼šè¦†ç›–temperature
        }                                 // åˆå¹¶åï¼š{temperature: 0.9, max_tokens: 1000, model: "gpt-4"}
      },
      {
        "provider": "anthropic",
        "overrideParams": { 
          "model": "claude-3-sonnet"
        }                                 // åˆå¹¶åï¼š{temperature: 0.7, max_tokens: 1000, model: "claude-3-sonnet"}
      }
    ]
  }
}
```

### 4. å¤šå±‚åµŒå¥—ç»§æ‰¿

```json
{
  "x-portkey-config": {
    "retry": { "attempts": 3 },
    "cache": { "mode": "simple", "max_age": 7200 },
    "request_timeout": 30000,            // çˆ¶çº§ï¼š30ç§’è¶…æ—¶
    "strategy": { "mode": "fallback" },
    "targets": [
      {
        "name": "ä¸»è¦é›†ç¾¤",
        "retry": { "attempts": 2 },      // ç¬¬ä¸€çº§å­ç›®æ ‡
        "strategy": { "mode": "loadbalance" },
        "targets": [
          {
            "provider": "openai",
            "weight": 0.7,
            "request_timeout": 15000     // ç¬¬äºŒçº§å­ç›®æ ‡ï¼šè¦†ç›–ä¸º15ç§’
          },
          {
            "provider": "openai",
            "weight": 0.3                 // ç»§æ‰¿ï¼š15ç§’è¶…æ—¶ï¼Œ2æ¬¡é‡è¯•
          }
        ]
      },
      {
        "name": "å¤‡ç”¨é›†ç¾¤",
        "provider": "anthropic"           // ç»§æ‰¿ï¼š30ç§’è¶…æ—¶ï¼Œ3æ¬¡é‡è¯•
      }
    ]
  }
}
```

### 5. Hooks å’Œ Guardrails ç»§æ‰¿

```json
{
  "x-portkey-config": {
    "before_request_hooks": [
      { "id": "global-auth", "type": "mutator" }
    ],                                   // çˆ¶çº§ï¼šå…¨å±€å‰ç½®é’©å­
    "default_input_guardrails": [
      { "default.contains": {"words": ["spam"], "operator": "none"} }
    ],                                   // çˆ¶çº§ï¼šé»˜è®¤è¾“å…¥é˜²æŠ¤
    "strategy": { "mode": "loadbalance" },
    "targets": [
      {
        "provider": "openai",
        "weight": 0.5                     // ç»§æ‰¿æ‰€æœ‰çˆ¶çº§é’©å­å’Œé˜²æŠ¤
      },
      {
        "provider": "anthropic",
        "before_request_hooks": [         // å­çº§ï¼šå®Œå…¨æ›¿æ¢é’©å­
          { "id": "anthropic-specific", "type": "mutator" }
        ],
        "input_guardrails": [             // å­çº§ï¼šæ·»åŠ é¢å¤–é˜²æŠ¤
          { "default.regexMatch": {"pattern": "\\d{3}-\\d{2}-\\d{4}"} }
        ],
        "weight": 0.5
      }
    ]
  }
}
```

### 6. ç‰¹æ®Šå­—æ®µç»§æ‰¿è¡Œä¸º

```json
{
  "x-portkey-config": {
    "custom_host": "https://api.primary.com",  // çˆ¶çº§è‡ªå®šä¹‰ä¸»æœº
    "forward_headers": ["x-user-id", "x-org"],  // çˆ¶çº§è½¬å‘å¤´
    "strict_open_ai_compliance": true,          // çˆ¶çº§ä¸¥æ ¼æ¨¡å¼
    "strategy": { "mode": "fallback" },
    "targets": [
      {
        "provider": "openai"                     // ç»§æ‰¿æ‰€æœ‰çˆ¶çº§é…ç½®
      },
      {
        "provider": "anthropic",
        "custom_host": "https://api.backup.com", // å­çº§ï¼šè¦†ç›–ä¸»æœº
        "forward_headers": ["x-api-key"],        // å­çº§ï¼šå®Œå…¨æ›¿æ¢è½¬å‘å¤´
        "strict_open_ai_compliance": false        // å­çº§ï¼šå…³é—­ä¸¥æ ¼æ¨¡å¼
      }
    ]
  }
}
```

### ç»§æ‰¿è§„åˆ™æ€»ç»“

| å­—æ®µç±»å‹                                   | ç»§æ‰¿è¡Œä¸º | ç¤ºä¾‹                                                         |
| ------------------------------------------ | -------- | ------------------------------------------------------------ |
| **æ ‡é‡å­—æ®µ** (`retry`, `cache`, `timeout`) | å­è¦†ç›–çˆ¶ | å­ç›®æ ‡è®¾ç½® `retry: {attempts: 2}` è¦†ç›–çˆ¶çº§çš„ `retry: {attempts: 5}` |
| **å¯¹è±¡å­—æ®µ** (`overrideParams`)            | æ·±åº¦åˆå¹¶ | çˆ¶çº§ `{temperature: 0.7}` + å­çº§ `{model: "gpt-4"}` = `{temperature: 0.7, model: "gpt-4"}` |
| **æ•°ç»„å­—æ®µ** (`hooks`, `forwardHeaders`)   | å®Œå…¨æ›¿æ¢ | å­çº§è®¾ç½®æ–°æ•°ç»„ä¼šå®Œå…¨æ›¿æ¢çˆ¶çº§æ•°ç»„                             |
| **å¸ƒå°”å­—æ®µ** (`strictOpenAiCompliance`)    | å­è¦†ç›–çˆ¶ | å­çº§ `false` è¦†ç›–çˆ¶çº§ `true`                                 |

### Notes

- é…ç½®ç»§æ‰¿æ˜¯é€’å½’çš„ï¼Œæ”¯æŒä»»æ„æ·±åº¦çš„åµŒå¥—
- ç»§æ‰¿åœ¨ `tryTargetsRecursively` å‡½æ•°çš„æ¯æ¬¡è°ƒç”¨æ—¶å‘ç”Ÿ
- å­ç›®æ ‡é…ç½®ä¼˜å…ˆçº§å§‹ç»ˆé«˜äºçˆ¶ç›®æ ‡
- ç©ºå€¼æˆ–æœªå®šä¹‰çš„å­—æ®µä¼šä»çˆ¶ç›®æ ‡ç»§æ‰¿
- JSON è·¯å¾„è¿½è¸ªå¸®åŠ©è°ƒè¯•å¤æ‚çš„ç»§æ‰¿å…³ç³»

## conditional

`strategy: "conditional"` æ˜¯ Portkey AI Gateway ä¸­çš„ä¸€ä¸ªè·¯ç”±ç­–ç•¥ï¼Œå®ƒå…è®¸æ‚¨æ ¹æ®è¯·æ±‚çš„å…ƒæ•°æ®ã€å‚æ•°æˆ– URL è·¯å¾„åŠ¨æ€é€‰æ‹©ç›®æ ‡æä¾›å•†ã€‚

### åŸºæœ¬ç”¨æ³•

æ¡ä»¶è·¯ç”±é€šè¿‡ `ConditionalRouter` ç±»å®ç° [1](#0-0) ï¼Œåœ¨ `tryTargetsRecursively` å‡½æ•°ä¸­è¢«è°ƒç”¨ [2](#0-1) ã€‚

### é…ç½®ç»“æ„

```json
{
  "strategy": {
    "mode": "conditional",
    "conditions": [
      {
        "query": { "æ¡ä»¶è¡¨è¾¾å¼" },
        "then": "ç›®æ ‡åç§°"
      }
    ],
    "default": "é»˜è®¤ç›®æ ‡åç§°"
  },
  "targets": [
    {
      "name": "ç›®æ ‡åç§°",
      "provider": "openai",
      "api_key": "..."
    }
  ]
}
```

### æ”¯æŒçš„æ“ä½œç¬¦

æ¡ä»¶è·¯ç”±æ”¯æŒå¤šç§æ¯”è¾ƒå’Œé€»è¾‘æ“ä½œç¬¦ [3](#0-2) ï¼š

#### æ¯”è¾ƒæ“ä½œç¬¦

- `$eq` - ç­‰äº
- `$ne` - ä¸ç­‰äº  
- `$gt` - å¤§äº
- `$gte` - å¤§äºç­‰äº
- `$lt` - å°äº
- `$lte` - å°äºç­‰äº
- `$in` - åœ¨æ•°ç»„ä¸­
- `$nin` - ä¸åœ¨æ•°ç»„ä¸­
- `$regex` - æ­£åˆ™åŒ¹é…

#### é€»è¾‘æ“ä½œç¬¦

- `$and` - é€»è¾‘ä¸
- `$or` - é€»è¾‘æˆ–

### æ¡ä»¶è¯„ä¼°

æ¡ä»¶å¯ä»¥åŸºäºä»¥ä¸‹ä¸Šä¸‹æ–‡æ•°æ® [4](#0-3) ï¼š

- `metadata` - æ¥è‡ª `x-portkey-metadata` å¤´éƒ¨çš„å…ƒæ•°æ®
- `params` - è¯·æ±‚å‚æ•°
- `url.pathname` - URL è·¯å¾„

ä½¿ç”¨ç‚¹å·è®¿é—®åµŒå¥—å±æ€§ï¼Œå¦‚ `metadata.user_tier` [5](#0-4) ã€‚

### å®é™…ç¤ºä¾‹

```json
{
  "strategy": {
    "mode": "conditional",
    "conditions": [
      {
        "query": { 
          "metadata.user_tier": { "$eq": "premium" }
        },
        "then": "gpt4-target"
      },
      {
        "query": {
          "$or": [
            { "params.model": { "$regex": "gpt-4" } },
            { "metadata.region": { "$in": ["us", "eu"] } }
          ]
        },
        "then": "anthropic-target"
      }
    ],
    "default": "gpt35-target"
  },
  "targets": [
    {
      "name": "gpt4-target",
      "provider": "openai",
      "api_key": "sk-...",
      "override_params": { "model": "gpt-4" }
    },
    {
      "name": "anthropic-target", 
      "provider": "anthropic",
      "api_key": "sk-ant-..."
    },
    {
      "name": "gpt35-target",
      "provider": "openai", 
      "api_key": "sk-...",
      "override_params": { "model": "gpt-3.5-turbo" }
    }
  ]
}
```

### æ‰§è¡Œæµç¨‹

1. è§£æ `x-portkey-metadata` å¤´éƒ¨è·å–å…ƒæ•°æ® [6](#0-5) 
2. åˆ›å»º `ConditionalRouter` å®ä¾‹ [7](#0-6) 
3. æŒ‰é¡ºåºè¯„ä¼°æ¯ä¸ªæ¡ä»¶ [8](#0-7) 
4. è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…æ¡ä»¶çš„ç›®æ ‡
5. å¦‚æœæ— åŒ¹é…ä¸”æœ‰é»˜è®¤å€¼ï¼Œè¿”å›é»˜è®¤ç›®æ ‡ [9](#0-8) 
6. å¦åˆ™æŠ›å‡ºé”™è¯¯ [10](#0-9) 

### Notes

- æ¡ä»¶æŒ‰é¡ºåºè¯„ä¼°ï¼Œç¬¬ä¸€ä¸ªåŒ¹é…çš„æ¡ä»¶ç”Ÿæ•ˆ
- ç›®æ ‡å¿…é¡»é€šè¿‡ `name` å­—æ®µåœ¨ `targets` æ•°ç»„ä¸­å®šä¹‰
- æ¡ä»¶è·¯ç”±åœ¨ schema éªŒè¯ä¸­å—æ”¯æŒ [11](#0-10) 
- æ”¯æŒåµŒå¥—çš„é€»è¾‘æ“ä½œç¬¦ç»„åˆå¤æ‚æ¡ä»¶

## ç›‘æ§å’Œå¯è§‚æµ‹æ€§

### response

éœ€è¦è§£æå“åº”ä½“ï¼ˆresponse bodyï¼‰æ¥è·å–``ç”¨é‡ä¿¡æ¯``ã€‚Portkey Gatewayä¼šå°†å„ä¸ªproviderçš„ç”¨é‡å­—æ®µç»Ÿä¸€è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼ã€‚ [1](#3-0) 

#### ç»Ÿä¸€çš„ç”¨é‡å­—æ®µç»“æ„

æ‰€æœ‰providerçš„å“åº”éƒ½ä¼šè¢«è½¬æ¢ä¸ºæ ‡å‡†çš„`usage`ç»“æ„ [2](#3-1) ï¼š

```typescript
usage: {
  prompt_tokens: number;           // è¾“å…¥tokenæ•°
  completion_tokens: number;       // è¾“å‡ºtokenæ•°  
  total_tokens: number;            // æ€»tokenæ•°
  completion_tokens_details?: {    // å¯é€‰çš„è¾“å‡ºè¯¦æƒ…
    reasoning_tokens?: number;
    audio_tokens?: number;
  };
  prompt_tokens_details?: {        // å¯é€‰çš„è¾“å…¥è¯¦æƒ…
    cached_tokens?: number;
    audio_tokens?: number;
  };
  // Anthropicç¼“å­˜ç›¸å…³
  cache_read_input_tokens?: number;
  cache_creation_input_tokens?: number;
}
```

####  è·å–ç”¨é‡ä¿¡æ¯çš„ä»£ç 

```javascript
const result = await response.json();
const usage = result.usage;

console.log('ç”¨é‡ä¿¡æ¯:', {
  prompt_tokens: usage.prompt_tokens,
  completion_tokens: usage.completion_tokens,
  total_tokens: usage.total_tokens,
  cached_tokens: usage.prompt_tokens_details?.cached_tokens || 0
});
```

#### Notes

1. **å­—æ®µç»Ÿä¸€æ€§**ï¼šç»è¿‡Gatewayè½¬æ¢åï¼Œæ‰€æœ‰providerçš„ç”¨é‡å­—æ®µéƒ½éµå¾ª`CResponse`æ¥å£å®šä¹‰ [6](#3-5) ï¼Œç¡®ä¿å®¢æˆ·ç«¯ä»£ç çš„ä¸€è‡´æ€§ã€‚

2. **ç‰¹æ®Šå­—æ®µ**ï¼šæŸäº›providerç‰¹æœ‰çš„å­—æ®µï¼ˆå¦‚Anthropicçš„ç¼“å­˜tokenã€Googleçš„reasoning tokenï¼‰ä¼šè¢«ä¿ç•™åœ¨`_details`å­—æ®µä¸­ [7](#3-6) ã€‚

3. **æµå¼å“åº”**ï¼šåœ¨æµå¼å“åº”ä¸­ï¼Œusageä¿¡æ¯å¯èƒ½åœ¨æœ€åçš„chunkä¸­è¿”å› [8](#3-7) ã€‚

4. **ç¼ºå¤±å¤„ç†**ï¼šå¦‚æœproviderä¸æä¾›æŸäº›ä¿¡æ¯ï¼Œå¯¹åº”å­—æ®µä¼šè®¾ä¸º0æˆ–undefined [9](#3-8) ã€‚

### headers

å“åº”å¤´ä¿¡æ¯éå¸¸æœ‰ç”¨ï¼Œå¯ä»¥ç”¨äºå¤šç§åœºæ™¯ã€‚Portkey Gatewayçš„è®¾è®¡å°±æ˜¯ä¸ºäº†è®©è¿™äº›å…ƒæ•°æ®èƒ½å¤Ÿè¢«å®¢æˆ·ç«¯å’Œä¸­é—´ä»¶åˆ©ç”¨ã€‚ [1](#4-0) 

#### Portkey Gateway å¯è§‚æµ‹æ€§å“åº”å¤´è¡¨æ ¼

| å“åº”å¤´åç§° | æ¥æº | åº”ç”¨åœºæ™¯ | è¯´æ˜ |
|-----------|------|----------|------|
| `x-portkey-cache-status` | Portkey Gateway | ç¼“å­˜ç›‘æ§ã€æ€§èƒ½ä¼˜åŒ– | æŒ‡ç¤ºç¼“å­˜çŠ¶æ€ï¼ˆDISABLED/HITç­‰ï¼‰ [1](#5-0)  |
| `x-portkey-last-used-option-index` | Portkey Gateway | é…ç½®è°ƒè¯•ã€è·¯ç”±åˆ†æ | æ˜¾ç¤ºä½¿ç”¨çš„é…ç½®ç›®æ ‡è·¯å¾„ [2](#5-1)  |
| `x-portkey-provider` | Portkey Gateway | æˆæœ¬åˆ†æã€æä¾›å•†ç›‘æ§ | æ ‡è¯†å®é™…è°ƒç”¨çš„AIæä¾›å•† [3](#5-2)  |
| `x-portkey-retry-attempt-count` | Portkey Gateway | ç¨³å®šæ€§ç›‘æ§ã€æ•…éšœåˆ†æ | è®°å½•é‡è¯•æ¬¡æ•°ï¼Œ0è¡¨ç¤ºé¦–æ¬¡æˆåŠŸ [4](#5-3)  |
| `x-portkey-trace-id` | Portkey Gateway | åˆ†å¸ƒå¼è¿½è¸ªã€æ—¥å¿—å…³è” | ç”¨äºè·¨æœåŠ¡è¯·æ±‚è¿½è¸ª [5](#5-4)  |
| `req-arrive-time` | åŸºç¡€è®¾æ–½ | æ€§èƒ½ç›‘æ§ã€å»¶è¿Ÿåˆ†æ | è¯·æ±‚åˆ°è¾¾ç½‘å…³çš„Unixæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰ |
| `req-cost-time` | åŸºç¡€è®¾æ–½ | æ€§èƒ½ç›‘æ§ã€SLAç›‘æ§ | è¯·æ±‚æ€»å¤„ç†æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ |
| `resp-start-time` | åŸºç¡€è®¾æ–½ | æ€§èƒ½åˆ†æã€å»¶è¿Ÿåˆ†è§£ | å“åº”å¼€å§‹å‘é€çš„æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰ |
| `x-envoy-upstream-service-time` | åŸºç¡€è®¾æ–½ | ä¸Šæ¸¸æœåŠ¡ç›‘æ§ | Envoyä»£ç†è®°å½•çš„ä¸Šæ¸¸æœåŠ¡å¤„ç†æ—¶é—´ |
| `x-request-id` | åŸºç¡€è®¾æ–½ | è¯·æ±‚è¿½è¸ªã€æ—¥å¿—å…³è” | è¯·æ±‚çš„å”¯ä¸€æ ‡è¯†ç¬¦ |

#### å¦‚ä½•è·å–å“åº”å¤´

å¤´éƒ¨è®¿é—®æ—¶æœºï¼šå¿…é¡»åœ¨è°ƒç”¨ response.json() æˆ– response.text() ä¹‹å‰è®¿é—®å¤´éƒ¨ï¼Œå› ä¸ºè¿™äº›æ–¹æ³•ä¼šæ¶ˆè´¹å“åº”æµã€‚ globals.ts:13-28

å¤´éƒ¨åç§°æ ¼å¼ï¼šæ‰€æœ‰ Portkey å¤´éƒ¨éƒ½ä½¿ç”¨ x-portkey- å‰ç¼€ï¼Œåœ¨ HEADER_KEYS ä¸­å®šä¹‰

Gateway æ·»åŠ çš„å“åº”å¤´

æ ¹æ®ä»£ç ï¼ŒGateway ä¼šæ·»åŠ ä»¥ä¸‹å“åº”å¤´ï¼š

 * x-portkey-retry-attempt-count: é‡è¯•æ¬¡æ•°
 * x-portkey-trace-id: è¿½è¸ªID
 * x-portkey-last-used-option-index: ä½¿ç”¨çš„é€‰é¡¹ç´¢å¼•
 * x-portkey-cache-status: ç¼“å­˜çŠ¶æ€ï¼ˆå¦‚æœæœ‰ï¼‰
 * x-portkey-provider: ä½¿ç”¨çš„æä¾›å•†

#### ä¸»è¦åˆ©ç”¨åœºæ™¯

##### 1. ç›‘æ§å’Œå¯è§‚æµ‹æ€§

- **æ€§èƒ½ç›‘æ§**ï¼š`req-cost-time`ã€`x-envoy-upstream-service-time` å¯ç”¨äºåˆ†æè¯·æ±‚å»¶è¿Ÿ
- **ç¼“å­˜æ•ˆæœ**ï¼š`x-portkey-cache-status` ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡
- **é‡è¯•ç»Ÿè®¡**ï¼š`x-portkey-retry-attempt-count` è·Ÿè¸ªç³»ç»Ÿç¨³å®šæ€§

##### 2. è°ƒè¯•å’Œæ•…éšœæ’æŸ¥

- **è¯·æ±‚è¿½è¸ª**ï¼š`x-portkey-trace-id` ç”¨äºåˆ†å¸ƒå¼è¿½è¸ªï¼Œå…³è”å¤šä¸ªæœåŠ¡è°ƒç”¨ [2](#4-1) 
- **é…ç½®è·¯å¾„**ï¼š`x-portkey-last-used-option-index` å¸®åŠ©å®šä½ä½¿ç”¨äº†å“ªä¸ªé…ç½®ç›®æ ‡
- **æä¾›å•†è¯†åˆ«**ï¼š`x-portkey-provider` å¿«é€Ÿè¯†åˆ«å®é™…è°ƒç”¨çš„AIæœåŠ¡

##### 3. ä¸šåŠ¡ç»Ÿè®¡å’Œæˆæœ¬åˆ†æ

```javascript
// ç¤ºä¾‹ï¼šåˆ©ç”¨å“åº”å¤´è¿›è¡Œç»Ÿè®¡
const stats = {
  provider: response.headers.get('x-portkey-provider'),
  cacheHit: response.headers.get('x-portkey-cache-status') !== 'DISABLED',
  retryCount: parseInt(response.headers.get('x-portkey-retry-attempt-count')),
  latency: parseInt(response.headers.get('req-cost-time')),
  configPath: response.headers.get('x-portkey-last-used-option-index')
};

// å‘é€åˆ°ç›‘æ§ç³»ç»Ÿæˆ–å†™å…¥æ—¥å¿—
analytics.track('api_request', stats);
```

##### 4. æ’ä»¶ç³»ç»Ÿé›†æˆ

æ’ä»¶ç³»ç»Ÿå¯ä»¥åˆ©ç”¨è¿™äº›å¤´éƒ¨ä¿¡æ¯ï¼š
- **å®‰å…¨æ’ä»¶**ï¼šä½¿ç”¨ `x-portkey-trace-id` è¿›è¡Œå®‰å…¨å®¡è®¡è¿½è¸ª [3](#4-2) 
- **æ—¥å¿—æ’ä»¶**ï¼šè®°å½•å®Œæ•´çš„è¯·æ±‚ä¸Šä¸‹æ–‡ä¿¡æ¯ [4](#4-3) 

##### 5. åŠ¨æ€è·¯ç”±å†³ç­–

åŸºäºå“åº”å¤´ä¿¡æ¯å¯ä»¥åšå‡ºå®æ—¶å†³ç­–ï¼š
```javascript
// æ ¹æ®ç¼“å­˜çŠ¶æ€è°ƒæ•´ç­–ç•¥
if (response.headers.get('x-portkey-cache-status') === 'DISABLED') {
  // å¯ç”¨ç¼“å­˜æˆ–è°ƒæ•´é…ç½®
}

// æ ¹æ®é‡è¯•æ¬¡æ•°åˆ¤æ–­æä¾›å•†å¥åº·åº¦
const retryCount = parseInt(response.headers.get('x-portkey-retry-attempt-count'));
if (retryCount > 2) {
  // æ ‡è®°æä¾›å•†ä¸ºä¸å¥åº·ï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨æä¾›å•†
}
```

#### Notes

1. **æ€§èƒ½è€ƒè™‘**ï¼šå“åº”å¤´ä¿¡æ¯è½»é‡ä¸”å®æ—¶ï¼Œæ— éœ€è§£æå“åº”ä½“å³å¯è·å–å…³é”®æŒ‡æ ‡
2. **æ ‡å‡†åŒ–**ï¼šæ‰€æœ‰ `x-portkey-` å‰ç¼€çš„å¤´éƒ¨åœ¨ `RESPONSE_HEADER_KEYS` ä¸­ç»Ÿä¸€å®šä¹‰ [5](#4-4) 
3. **æ‰©å±•æ€§**ï¼šæ’ä»¶ç³»ç»Ÿå¯ä»¥è®¿é—®å®Œæ•´çš„è¯·æ±‚ä¸Šä¸‹æ–‡ï¼ŒåŒ…æ‹¬è¿™äº›å“åº”å¤´ä¿¡æ¯
4. **æ—¥å¿—é›†æˆ**ï¼š`LogsService` ä¼šè‡ªåŠ¨æ”¶é›†è¿™äº›ä¿¡æ¯ç”¨äºè¯·æ±‚æ—¥å¿—è®°å½• [4](#4-3) 

è¿™äº›å“åº”å¤´è®¾è®¡ä¸ºå¯è¢«å®¢æˆ·ç«¯ã€ç›‘æ§ç³»ç»Ÿå’Œæ’ä»¶å……åˆ†åˆ©ç”¨ï¼Œæ˜¯Gatewayå¯è§‚æµ‹æ€§æ¶æ„çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

### model ä¿¡æ¯

model ä¿¡æ¯åœ¨ **å“åº”ä½“ï¼ˆresponse bodyï¼‰** ä¸­ï¼Œä¸åœ¨å“åº”å¤´é‡Œã€‚ [1](#8-0) 

#### å“åº”ä½“ä¸­çš„ model å­—æ®µ

åœ¨ Portkey Gateway è¿”å›çš„æ ‡å‡†å“åº”æ ¼å¼ä¸­ï¼Œmodel å­—æ®µä½äºå“åº”ä½“çš„æ ¹çº§åˆ«ï¼š

```json
{
  "id": "chatcmpl-dbe92584-24c0-4236-aed4-e8de588afa2e",
  "object": "chat.completion", 
  "created": 1764438958,
  "model": "qwen-turbo",
  "choices": [...],
  "usage": {...},
  "provider": "dashscope"
}
```

#### Model å­—æ®µçš„æ¥æº

Gateway åœ¨å“åº”è½¬æ¢è¿‡ç¨‹ä¸­ä¼šè®¾ç½® model å­—æ®µï¼Œé€šå¸¸ä»è¯·æ±‚å‚æ•°ä¸­è·å–ï¼š [2](#8-1) 

```javascript
model: requestBody.model
```

#### æ ‡å‡†åŒ–å“åº”ç»“æ„

æ‰€æœ‰ provider çš„å“åº”éƒ½ä¼šè¢«è½¬æ¢ä¸ºåŒ…å« model å­—æ®µçš„æ ‡å‡†æ ¼å¼ï¼š [3](#8-2) 

```typescript
interface CResponse {
  id: string;
  object: string;
  created: number;
  model: string;  // æ ‡å‡†çš„ model å­—æ®µ
  choices: any[];
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
```

####  Notes

1. **å“åº”å¤´ä¸­æ²¡æœ‰ model ä¿¡æ¯**ï¼šPortkey Gateway çš„å“åº”å¤´ä¸»è¦åŒ…å«å¯è§‚æµ‹æ€§ä¿¡æ¯ï¼ˆå¦‚ `x-portkey-provider`ã€`x-portkey-cache-status` ç­‰ï¼‰ï¼Œä¸åŒ…å« model å­—æ®µ [4](#8-3) 

2. **Provider å­—æ®µåŒºåˆ«**ï¼šå“åº”ä½“ä¸­åŒæ—¶åŒ…å« `model` å’Œ `provider` å­—æ®µï¼š
   - `model`ï¼šå…·ä½“çš„æ¨¡å‹åç§°ï¼ˆå¦‚ "qwen-turbo"ï¼‰
   - `provider`ï¼šæä¾›å•†åç§°ï¼ˆå¦‚ "dashscope"ï¼‰

3. **è·å–æ–¹å¼**ï¼šæ‚¨éœ€è¦é€šè¿‡ `await response.json()` è§£æå“åº”ä½“æ¥è·å– model ä¿¡æ¯ [5](#8-4) 

4. **ç»Ÿä¸€æ€§**ï¼šç»è¿‡ Gateway è½¬æ¢åï¼Œæ‰€æœ‰ provider çš„å“åº”éƒ½éµå¾ªç›¸åŒçš„ç»“æ„ï¼Œç¡®ä¿å®¢æˆ·ç«¯ä»£ç çš„ä¸€è‡´æ€§ã€‚

# Neuropia AI èšåˆå¹³å°é…ç½®ç³»ç»Ÿå’Œæ¶æ„è®¾è®¡

## 1ï¸âƒ£ æ•°æ®åº“éƒ¨åˆ†

```postgresql
-- DDL generated by Postico 2.3
-- Not all database features are supported. Do not use for backup.

-- Table Definition ----------------------------------------------

CREATE TABLE data.config_nodes (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text,
    parent_id uuid REFERENCES data.config_nodes(id) ON DELETE CASCADE,
    config_data jsonb NOT NULL DEFAULT '{}'::jsonb,
    mount_policy text DEFAULT 'leaf_only'::text CHECK (mount_policy = ANY (ARRAY['leaf_only'::text, 'any_node'::text, 'none'::text])),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    computed_config jsonb,
    CONSTRAINT config_nodes_id_not_null ,
    CONSTRAINT config_nodes_name_not_null ,
    CONSTRAINT config_nodes_config_data_not_null 
);

-- Indices -------------------------------------------------------

CREATE UNIQUE INDEX config_nodes_pkey ON data.config_nodes(id uuid_ops);
CREATE UNIQUE INDEX config_nodes_name_key ON data.config_nodes(name text_ops);
CREATE INDEX idx_config_nodes_parent ON data.config_nodes(parent_id uuid_ops) WHERE parent_id IS NOT NULL;
CREATE INDEX idx_config_nodes_active ON data.config_nodes(is_active bool_ops) WHERE is_active = true;
CREATE INDEX idx_config_nodes_name ON data.config_nodes(name text_ops);

-- Triggers -------------------------------------------------------

CREATE TRIGGER trg_refresh_node
  AFTER INSERT OR UPDATE OF parent_id, config_data ON data.config_nodes
  FOR EACH ROW
  EXECUTE FUNCTION data.on_node_change();

CREATE OR REPLACE TRIGGER notify_node_changed_trigger
    AFTER UPDATE OF parent_id, config_data
    ON data.config_nodes
    FOR EACH ROW
    EXECUTE FUNCTION data.notify_node_changed();
  
CREATE OR REPLACE FUNCTION data.on_node_change()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- âš¡ æ³¨æ„è¿™é‡Œç”¨ PERFORMï¼Œè€Œä¸æ˜¯ SELECT
    PERFORM data.refresh_node_and_descendants(NEW.id);
    RETURN NEW;
END;
$BODY$;

-- é€šçŸ¥ Node.jsï¼ˆç”¨äº Redis ç¼“å­˜å¤±æ•ˆï¼‰
CREATE OR REPLACE FUNCTION data.notify_node_changed()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
 DECLARE vk_ids text[]; BEGIN SELECT array_agg(id) INTO vk_ids FROM data.virtual_key WHERE primary_config_node_id = NEW.id; PERFORM pg_notify( 'node_changed', json_build_object( 'node_id', NEW.id, 'virtual_key_ids', COALESCE(vk_ids, ARRAY[]::text[]) )::text ); RETURN NEW; END; 
$BODY$;
```

```postgresql
-- DDL generated by Postico 2.3
-- Not all database features are supported. Do not use for backup.

-- Table Definition ----------------------------------------------

CREATE TABLE data.virtual_key (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES data.user_profile(user_id),
    virtual_key text NOT NULL UNIQUE,
    name text NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    key_type_id uuid REFERENCES data.virtual_key_types(id),
    key_prefix text,
    primary_config_node_id uuid REFERENCES data.config_nodes(id),
    config_data jsonb NOT NULL DEFAULT '{}'::jsonb,
    computed_config jsonb,
    CONSTRAINT virtual_key_id_not_null ,
    CONSTRAINT virtual_key_user_id_not_null ,
    CONSTRAINT virtual_key_virtual_key_not_null ,
    CONSTRAINT virtual_key_name_not_null ,
    CONSTRAINT virtual_key_config_data_not_null 
);

-- Indices -------------------------------------------------------

CREATE UNIQUE INDEX virtual_key_pkey ON data.virtual_key(id uuid_ops);
CREATE UNIQUE INDEX virtual_key_virtual_key_key ON data.virtual_key(virtual_key text_ops);

-- Triggers -------------------------------------------------------

CREATE TRIGGER compute_virtual_key_config_trigger
  BEFORE INSERT OR UPDATE OF primary_config_node_id, config_data ON data.virtual_key
  FOR EACH ROW
  EXECUTE FUNCTION data.compute_virtual_key_config_trigger_func();

CREATE OR REPLACE FUNCTION data.compute_virtual_key_config_trigger_func()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    NEW.computed_config :=
        data.refresh_virtual_key_computed_config(NEW.id);

    PERFORM pg_notify('virtual_key_config_changed', NEW.id::text);
    RETURN NEW;
END;
$BODY$;
```

## 2ï¸âƒ£ Node.js + Redis ç¼“å­˜é€»è¾‘

```
const { Client } = require('pg');
const Redis = require('ioredis');
import { createClient } from '@supabase/postgrest-js';


const redis = new Redis();

const pgClient = new Client({ /* connection config */ });
const redis = new Redis({ /* connection config */ });

await pgClient.connect();
await redis.connect();

// ç›‘å¬ pg_notify
pgClient.query('LISTEN virtual_key_config_changed');
pgClient.query('LISTEN node_changed');

// å¯åŠ¨æ—¶åˆ·æ–°: åˆ·æ–° node â†’ virtual_key æ˜ å°„
async function refreshNodeVKMapping(nodeId) {
  // ä» PG æŸ¥å‡ºæ‰€æœ‰ virtual_key
  const res = await pgClient.query(
    `SELECT id FROM data.virtual_key WHERE primary_config_node_id = $1`,
    [nodeId]
  );
  const vkIds = res.rows.map(r => r.id);

  await redis.set(`node_vk_mapping:${nodeId}`, JSON.stringify(vkIds));
  return vkIds;
}

pgClient.on('notification', async (msg) => {
  if (msg.channel === 'node_changed') {
    const nodeId = msg.payload;

    // å…ˆä» Redis æ‹¿æ˜ å°„
    let vkIds = await redis.get(`node_vk_mapping:${nodeId}`);
    if (vkIds) {
      vkIds = JSON.parse(vkIds);
    } else {
      // ç¼“å­˜æ²¡å‘½ä¸­ï¼Œåˆ·æ–°æ˜ å°„
      vkIds = await refreshNodeVKMapping(nodeId);
    }

    // æ¸…ç†æ¯ä¸ª virtual_key çš„ config ç¼“å­˜
    for (const vkId of vkIds) {
      await redis.del(`vk_config:${vkId}`);
    }
  } else if (msg.channel === 'user_config_changed') {
    const userId = msg.payload;
    await redis.del(`user_computed_config:${userId}`);
  }
});

// è·å¾—virtual_key çš„config
async function getUserConfig(userId) {
  const cacheKey = `user_computed_config:${userId}`;
  const cached = await redis.get(cacheKey);
  if (cached) return JSON.parse(cached);

  // è°ƒç”¨ PostgREST æš´éœ²çš„æ•°æ®åº“å‡½æ•° api.getVirtualKeyConfig
  const { data, error } = await postgrest
    .rpc('getVirtualKeyConfig', { p_user_id: userId });

  if (error) {
    console.error('PostgREST get_virtualkey_config error:', error);
    throw error;
  }

  // å‡½æ•°è¿”å›ç»“æ„å¿…é¡»ç”±ä½ åœ¨æ•°æ®åº“é‡Œå®šä¹‰
  const config = data ?? {};

  await redis.set(cacheKey, JSON.stringify(config));
  return config;
}

export { getUserConfig };
```

**ç”¨æˆ·ä¿®æ”¹ config_data â†’ è§¦å‘å™¨è‡ªåŠ¨åˆ·æ–° computed_config + pg_notify**

**èŠ‚ç‚¹ä¿®æ”¹ â†’ pg_notify â†’ Node.js æ¸…ç†å—å½±å“ç”¨æˆ·ç¼“å­˜**

**ç”¨æˆ·è¯·æ±‚ â†’ Redis ç¼“å­˜å‘½ä¸­ç›´æ¥è¿”å›ï¼Œå¦åˆ™æŒ‰ computed_config è¿”å›å¹¶å†™ç¼“å­˜**

**æ— éœ€å…¨è¡¨åˆ·æ–°ç”¨æˆ·ï¼Œæ€§èƒ½å‹å¥½**

## virtual key

virtual key åº”åœ¨ä¸šåŠ¡æµç¨‹ä¸­ä½“ç°, ç™»é™†->æ³¨å†Œ-å»ºç«‹/åˆ é™¤/æ›´æ–°

```postgresql
CREATE TABLE IF NOT EXISTS data.virtual_key
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL,
    virtual_key text COLLATE pg_catalog."default" NOT NULL,
    name text COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    key_type_id uuid,
    key_prefix text COLLATE pg_catalog."default",
    CONSTRAINT virtual_key_pkey PRIMARY KEY (id),
    CONSTRAINT virtual_key_virtual_key_key UNIQUE (virtual_key),
    CONSTRAINT virtual_key_key_type_id_fkey FOREIGN KEY (key_type_id)
        REFERENCES data.virtual_key_types (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT virtual_key_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES data.user_profile (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
```

```postgresql
CREATE OR REPLACE FUNCTION api.activate_virtual_key(
	p_virtual_key text,
	p_reason text DEFAULT NULL::text)
    RETURNS void
    LANGUAGE 'plpgsql'
```

```postgresql
CREATE OR REPLACE FUNCTION api.create_virtual_key(
	p_user_id uuid,
	p_name text,
	p_description text DEFAULT NULL::text,
	p_key_type_id uuid DEFAULT NULL::uuid,
	p_key_prefix text DEFAULT NULL::text)
```

```postgresql
CREATE OR REPLACE VIEW api.virtual_keys
 AS
 SELECT vk.id,
    vk.user_id,
    vk.virtual_key,
    vk.name,
    vk.description,
    vk.is_active,
    vk.created_at,
    vk.updated_at,
    up.username,
    up.tenant_id
   FROM data.virtual_key vk
     JOIN data.user_profile up ON vk.user_id = up.user_id;

ALTER TABLE api.virtual_keys
    OWNER TO api_views_owner;

GRANT ALL ON TABLE api.virtual_keys TO api_views_owner;
GRANT SELECT ON TABLE api.virtual_keys TO sys_admin;
```

# Neuropia_API_GATEWAY

## ç›®å‰è®¾è®¡

```mermaid
graph TB
    classDef user fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef business fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef config fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    classDef gateway fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef ai fill:#ffebee,stroke:#b71c1c,stroke-width:2px

    U[ç»ˆç«¯ç”¨æˆ·]:::user
    A[neuropia_api_gateway]:::business
    C[é…ç½®æœåŠ¡<br/>neuropid-config-service]:::config
    P[Portkeyç½‘å…³<br/>portkey-gateway]:::gateway
    O[OpenAI]:::ai
    AN[Anthropic]:::ai

    U -->|1 POST /api/chat<br/>ç”¨æˆ·æ¶ˆæ¯| A
    A -->|2 GET /config/user123<br/>æŸ¥è¯¢ç”¨æˆ·é…ç½®| C
    C -->|3 è¿”å› Portkey é…ç½® JSON| A
    A -->|4 POST /v1/chat/completions<br/>æ¶ˆæ¯ + é…ç½® + å…ƒæ•°æ®| P
    P -->|5 æŒ‰é…ç½®è°ƒç”¨ AI ä¾›åº”å•†| O
    P -->|5 æŒ‰é…ç½®è°ƒç”¨ AI ä¾›åº”å•†| AN
    O -->|6 AI å“åº”| P
    AN -->|6 AI å“åº”| P
    P -->|7 è¿”å› AI ç»“æœ| A
    A -->|8 è¿”å›ä¸šåŠ¡å“åº”| U

    subgraph é…ç½®å†…å®¹ç¤ºä¾‹
        C1["VIP ç”¨æˆ·é…ç½®:<br/>- GPT-4<br/>- é«˜æƒé‡"]
        C2["å…è´¹ç”¨æˆ·é…ç½®:<br/>- GPT-3.5<br/>- æˆæœ¬ä¼˜åŒ–"]
    end

    C --> C1
    C --> C2

```

```
neuropia_api_gateway/
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ middleware
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ auth.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ virtualKey.js
â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ chat.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ users.js
â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ billingService.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ configService.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ userService.js
â”‚Â Â  â”œâ”€â”€ app.js
â”‚Â Â  â””â”€â”€ server.js
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ package-lock.json
â””â”€â”€ package.json
```

```js
// neuropia_api_gateway/src/app.js
const express = require("express");
const cors = require("cors");
// const { AuthMiddleware } = require("./middleware/auth");
const { VirtualKeyMiddleware } = require("./middleware/virtualKey");
const chatRoutes = require("./routes/chat");
const configRoutes = require("./routes/config");
const userRoutes = require("./routes/users");
const RedisService = require("@shared/clients/redis");

class NeuropiaGateway {
  constructor() {
    this.app = express();
    // ä¸åœ¨æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–
  }

  async initialize() {
    try {
      console.log("Initializing Neuropia API Gateway...");

      // 1. å…ˆè¿æ¥ Redis
      await RedisService.connect();
      console.log("Redis connected successfully");

      // 2. è®¾ç½®ä¸­é—´ä»¶
      this.setupMiddleware();

      // 3. è®¾ç½®è·¯ç”±
      this.setupRoutes();

      console.log("Neuropia API Gateway initialized successfully");
    } catch (error) {
      console.error("Initialization failed:", error);
      throw error;
    }
  }

  setupMiddleware() {
    this.app.use(cors());
    this.app.use(express.json());

    // å…¨å±€è®¤è¯ä¸­é—´ä»¶ï¼ˆå¥åº·æ£€æŸ¥é™¤å¤–ï¼‰
    // this.app.use(AuthMiddleware.authenticate);
  }

  setupRoutes() {
    // åªæœ‰èŠå¤©è·¯ç”±éœ€è¦ Virtual Key éªŒè¯
    this.app.use("/api/chat", VirtualKeyMiddleware.validate, chatRoutes);

    // é…ç½®å’Œç”¨æˆ·è·¯ç”±åªéœ€è¦è®¤è¯ï¼Œä¸éœ€è¦ Virtual Key
    this.app.use("/api/config", configRoutes);
    this.app.use("/api/users", userRoutes);

    // å¥åº·æ£€æŸ¥ - å®Œå…¨å…¬å¼€ï¼ˆåŒ…å« Redis çŠ¶æ€ï¼‰
    this.app.get("/health", async (req, res) => {
      const redisHealth = await RedisService.healthCheck();

      res.json({
        status: "ok",
        service: "neuropia_api_gateway",
        redis: redisHealth ? "connected" : "disconnected",
        timestamp: new Date().toISOString(),
      });
    });

    // 404 å¤„ç†
    this.app.use("*", (req, res) => {
      res.status(404).json({
        error: "Route not found",
        code: "ROUTE_NOT_FOUND",
      });
    });

    // å…¨å±€é”™è¯¯å¤„ç†
    this.app.use((err, req, res, next) => {
      console.error("Unhandled error:", err);
      res.status(500).json({
        error: "Internal server error",
        code: "INTERNAL_ERROR",
      });
    });
  }

  async start(port = 3001) {
    try {
      // å¼‚æ­¥åˆå§‹åŒ–
      await this.initialize();

      this.server = this.app.listen(port, () => {
        console.log(`Neuropia API Gateway running on port ${port}`);
      });

      // ä¼˜é›…å…³é—­å¤„ç†
      this.setupGracefulShutdown();

      return this.server;
    } catch (error) {
      console.error("Failed to start Neuropia API Gateway:", error);
      // ä¸è¦è°ƒç”¨ process.exit(1)ï¼Œè®©æµ‹è¯•æ¡†æ¶å¤„ç†é”™è¯¯
      throw error;
    }
  }

  setupGracefulShutdown() {
    const gracefulShutdown = async (signal) => {
      console.log(`Received ${signal}, shutting down gracefully...`);

      if (this.server) {
        this.server.close(() => {
          console.log("HTTP server closed");
        });
      }

      if (RedisService.client) {
        await RedisService.client.quit();
        console.log("Redis connection closed");
      }
    };

    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
  }
}

module.exports = NeuropiaGateway;

```

```js
// neuropia_api_gateway/src/server.js
require('module-alias/register');
require("dotenv").config();

const NeuropiaGateway = require("./app");

async function startServer() {
  try {
    console.log("ğŸš€ Starting Neuropia API Gateway...");

    const gateway = new NeuropiaGateway();
    const server = await gateway.start(process.env.PORT || 3001);

    console.log("âœ… Neuropia API Gateway started successfully");

    return server;
  } catch (error) {
    console.error("âŒ Failed to start Neuropia API Gateway:", error);
    // ä¸è¦è°ƒç”¨ process.exitï¼Œè®©è°ƒç”¨æ–¹å¤„ç†é”™è¯¯
    throw error;
  }
}

// åªæœ‰ç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶æ—¶æ‰å¯åŠ¨æœåŠ¡å™¨
if (require.main === module) {
  startServer().catch((error) => {
    console.error("Server startup failed:", error);
    process.exit(1);
  });
}

module.exports = startServer;

```

```js
// neuropia_api_gateway/src/routes/chat.js
const express = require('express');
const { BillingService } = require('../services/billingService');
const { ConfigService } = require('../services/configService');
const { RedisService } = require('@shared/clients/redis');
const router = express.Router();

// neuropia_api_gateway/src/routes/chat.js
router.post('/completions', async (req, res) => {
    try {
        const { userContext } = req;
        const requestBody = req.body;

        console.log('ğŸ¯ ç”¨æˆ·ä¸Šä¸‹æ–‡:', userContext);

        // ğŸ¯ æ–°å¢ï¼šè·å–å®Œæ•´é…ç½®ï¼ˆåŒ…å« model_access å’Œ rate_limitsï¼‰
        let allConfigs;
        try {
            allConfigs = await ConfigService.getAllConfigs(userContext, requestBody);
            console.log('âœ… Config Service è¿”å›å®Œæ•´é…ç½®:', JSON.stringify(allConfigs, null, 2));

            // ğŸ¯ æ–°å¢ï¼šä¸šåŠ¡é€»è¾‘æ£€æŸ¥
            await validateBusinessRules(allConfigs, userContext, requestBody);

        } catch (error) {
            console.warn('Config Service unavailable, using fallback config');
            allConfigs = getFallbackConfig(userContext, requestBody);
        }

        // ğŸ¯ ä¿®æ”¹ï¼šä½¿ç”¨ allConfigs.portkey_config
        const portkeyConfig = allConfigs.config || allConfigs;

        // éªŒè¯é…ç½®ç»“æ„
        if (!portkeyConfig.targets || !Array.isArray(portkeyConfig.targets) || portkeyConfig.targets.length === 0) {
            throw new Error('Invalid config from Config Service');
        }

        // 5. è°ƒç”¨ Portkey Gateway
        const portkeyResponse = await callPortkeyGateway(portkeyConfig, requestBody, userContext);

        res.json(portkeyResponse);
    } catch (error) {
        console.error('Chat completion error:', error);
        res.status(500).json({
            error: 'Internal server error',
            details: error.message
        });
    }
});

async function validateBusinessRules(allConfigs, userContext, requestBody) {
    const { model_access, rate_limits } = allConfigs;

    // 1. æ£€æŸ¥æ¨¡å‹æƒé™
    if (model_access?.allowed_models) {
        if (!model_access.allowed_models.includes(requestBody.model)) {
            throw new Error(`æ¨¡å‹ ${requestBody.model} ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­ã€‚å…è®¸çš„æ¨¡å‹: ${model_access.allowed_models.join(', ')}`);
        }
    }

    // 2. æ£€æŸ¥é¢‘ç‡é™åˆ¶
    if (rate_limits) {
        await checkRateLimits(userContext, rate_limits, requestBody);
    }

    // 3. æ£€æŸ¥å†…å®¹è¿‡æ»¤ï¼ˆå¦‚æœæœ‰ï¼‰
    if (model_access?.blocked_content_types) {
        await checkContentSafety(requestBody, model_access.blocked_content_types);
    }
}

// ğŸ¯ æ–°å¢ï¼šé¢‘ç‡é™åˆ¶æ£€æŸ¥
async function checkRateLimits(userContext, rateLimits, requestBody) {
    const { user_id, virtual_key } = userContext;

    // æ£€æŸ¥æ¯åˆ†é’Ÿè¯·æ±‚æ•°
    if (rateLimits.requests_per_minute) {
        const requestsKey = `rate_limit:requests:${user_id}:${virtual_key}`;
        const currentRequests = await RedisService.incr(requestsKey);

        if (currentRequests === 1) {
            await RedisService.expire(requestsKey, 60); // è®¾ç½®è¿‡æœŸæ—¶é—´
        }

        if (currentRequests > rateLimits.requests_per_minute) {
            throw new Error(`è¯·æ±‚é¢‘ç‡è¶…é™ã€‚é™åˆ¶: ${rateLimits.requests_per_minute} æ¬¡/åˆ†é’Ÿ`);
        }
    }

    // æ£€æŸ¥Tokené™åˆ¶
    if (rateLimits.max_tokens && requestBody.max_tokens > rateLimits.max_tokens) {
        throw new Error(`å•æ¬¡è¯·æ±‚Tokenæ•°è¶…é™ã€‚é™åˆ¶: ${rateLimits.max_tokens}ï¼Œè¯·æ±‚: ${requestBody.max_tokens}`);
    }
}

async function callPortkeyGateway(config, requestBody, userContext) {
    const target = config.targets[0];
    if (!target.provider || !target.api_key) {
        throw new Error('Invalid target configuration: missing provider or api_key');
    }

    const response = await fetch(`${process.env.PORTKEY_GATEWAY_URL}/v1/chat/completions`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${config.apikey}`,
            'Content-Type': 'application/json',
            'x-portkey-config': JSON.stringify(config),
            'x-portkey-provider': target.provider,
            'x-portkey-metadata': JSON.stringify({
                user_id: userContext.user_id,
                virtual_key: userContext.virtual_key,
                tier_name: userContext.tier_name,
                environment: process.env.NODE_ENV || 'development'
            })
        },
        body: JSON.stringify(requestBody)
    });

    console.log('ğŸ“¡ Portkey Gateway å“åº”çŠ¶æ€:', response.status);

    if (!response.ok) {
        const errorText = await response.text();
        console.error('âŒ Portkey Gateway é”™è¯¯:', errorText);
        throw new Error(`Portkey Gateway error: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    console.log('âœ… Portkey Gateway æˆåŠŸå“åº”');
    return result;
}

// è¾…åŠ©å‡½æ•°
function estimateTokenCount(messages, max_tokens) {
    const totalChars = messages.reduce((sum, msg) => sum + msg.content.length, 0);
    return {
        input: Math.ceil(totalChars / 4),
        output: max_tokens || 1000
    };
}

function extractUsageFromResponse(response) {
    return response.usage || { prompt_tokens: 0, completion_tokens: 0 };
}

function inferProviderFromModel(model) {
    if (model.includes('qwen')) return 'dashscope';
    if (model.includes('gpt')) return 'openai';
    if (model.includes('claude')) return 'anthropic';
    return 'dashscope'; // é»˜è®¤
}

function generatePromptHash(messages) {
    // ç®€åŒ–çš„å“ˆå¸Œç”Ÿæˆ
    return require('crypto')
        .createHash('md5')
        .update(JSON.stringify(messages))
        .digest('hex');
}

// å½“ Config Service ä¸å¯ç”¨æ—¶ï¼Œæä¾›ä¸€ä¸ªæœ€åŸºæœ¬çš„å¤‡ç”¨é…ç½®ã€‚
function getFallbackConfig(userContext, requestBody) {
    const provider = inferProviderFromModel(requestBody.model);

    return {
        // ğŸ¯ Portkey é…ç½®ï¼ˆä¿è¯AIæœåŠ¡å¯ç”¨ï¼‰
        portkey_config: {
            strategy: { mode: "fallback" },
            targets: [{
                provider: provider,
                api_key: getRealApiKey(provider),
                override_params: {
                    model: requestBody.model,
                    max_tokens: 2000,
                    temperature: 0.7
                }
            }]
        },
        // ğŸ¯ ä¸šåŠ¡é…ç½®ï¼ˆä¿å®ˆçš„é»˜è®¤å€¼ï¼‰
        rate_limits: {
            max_tokens: 4000,           // ä¿å®ˆçš„tokené™åˆ¶
            requests_per_minute: 30     // è¾ƒä½çš„é¢‘ç‡é™åˆ¶ï¼ˆä¿æŠ¤ç³»ç»Ÿï¼‰
        },
        model_access: {
            allowed_models: ['gpt-3.5-turbo', 'qwen-turbo'] // åªå…è®¸åŸºç¡€æ¨¡å‹
        }
    };
}

// ğŸ¯ æ·»åŠ è·å–çœŸå®API Keyçš„å‡½æ•°
function getRealApiKey(provider) {
    const providerKeys = {
        'dashscope': process.env.DASHSCOPE_API_KEY,
        'openai': process.env.OPENAI_API_KEY,
        'anthropic': process.env.ANTHROPIC_API_KEY
    };

    const apiKey = providerKeys[provider];
    if (!apiKey) {
        throw new Error(`No API key configured for provider: ${provider}`);
    }
    return apiKey;
}

module.exports = router;

```

```js
// neuropia_api_gateway/src/routes/config.js
const express = require("express");
const { RedisService } = require("@shared/clients/redis");
const router = express.Router();

/**
 * é…ç½®ç®¡ç†è·¯ç”±
 * æä¾›é…ç½®æŸ¥è¯¢ã€éªŒè¯å’Œé‡æ–°åŠ è½½åŠŸèƒ½
 */

/**
 * ğŸ†• è§£æç‰¹å®šé…ç½®ç±»å‹
 */
router.post("/resolve-config", async (req, res) => {
  try {
    const { config_type, target_level, scope_id, context } = req.body;

    const config = await PortkeyConfigGenerator.resolveConfig(
      config_type,
      target_level,
      scope_id,
      context,
    );

    res.json({
      success: true,
      config_type,
      config,
    });
  } catch (error) {
    console.error("Resolve config error:", error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

/**
 * ğŸ†• ç”ŸæˆåŠ¨æ€ Portkey é…ç½®
 */
router.post("/generate-dynamic-config", async (req, res) => {
  try {
    const { userContext, virtualKeyConfig, requestBody } = req.body;

    // éªŒè¯å¿…è¦å‚æ•°
    if (!userContext?.user_id || !userContext?.virtual_key) {
      return res.status(400).json({
        success: false,
        error: "Missing required user context",
      });
    }

    // ç”Ÿæˆé…ç½®
    const portkeyConfig = await PortkeyConfigGenerator.generateConfig(
      userContext,
      virtualKeyConfig,
      requestBody,
    );

    res.json({
      success: true,
      config: portkeyConfig,
      generated_at: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Generate dynamic config error:", error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

// è·å– Virtual Key é…ç½®
router.get("/virtual-keys/:virtualKey", async (req, res) => {
  try {
    const { virtualKey } = req.params;

    const config = await RedisService.getVirtualKey(virtualKey);
    if (!config) {
      return res.status(404).json({
        error: "Virtual key not found",
        code: "VIRTUAL_KEY_NOT_FOUND",
      });
    }

    // è¿‡æ»¤æ•æ„Ÿä¿¡æ¯
    const safeConfig = {
      virtual_key: config.virtual_key,
      name: config.name,
      description: config.description,
      rate_limits: {
        rpm: config.rate_limit_rpm,
        tpm: config.rate_limit_tpm,
      },
      allowed_models: config.allowed_models,
      is_active: config.is_active,
      created_at: config.created_at,
    };

    res.json(safeConfig);
  } catch (error) {
    console.error("Get virtual key config error:", error);
    res.status(500).json({
      error: "Failed to get virtual key configuration",
      details: error.message,
    });
  }
});

// éªŒè¯ Virtual Key
router.post("/virtual-keys/validate", async (req, res) => {
  try {
    const { virtual_key, model } = req.body;

    if (!virtual_key) {
      return res.status(400).json({
        error: "Virtual key is required",
        code: "MISSING_VIRTUAL_KEY",
      });
    }

    const config = await RedisService.getVirtualKey(virtual_key);
    if (!config) {
      return res.status(401).json({
        error: "Invalid virtual key",
        code: "INVALID_VIRTUAL_KEY",
      });
    }

    if (!config.is_active) {
      return res.status(403).json({
        error: "Virtual key is inactive",
        code: "INACTIVE_VIRTUAL_KEY",
      });
    }

    // æ£€æŸ¥æ¨¡å‹æƒé™
    if (model && config.allowed_models && config.allowed_models.length > 0) {
      if (!config.allowed_models.includes(model)) {
        return res.status(403).json({
          error: `Model ${model} not allowed for this virtual key`,
          code: "MODEL_NOT_ALLOWED",
          allowed_models: config.allowed_models,
        });
      }
    }

    res.json({
      valid: true,
      virtual_key: config.virtual_key,
      name: config.name,
      rate_limits: {
        rpm: config.rate_limit_rpm,
        tpm: config.rate_limit_tpm,
      },
      allowed_models: config.allowed_models,
    });
  } catch (error) {
    console.error("Validate virtual key error:", error);
    res.status(500).json({
      error: "Validation failed",
      details: error.message,
    });
  }
});

// è·å–ç”¨æˆ·é…ç½®ä¸Šä¸‹æ–‡
router.get("/user-context/:userId", async (req, res) => {
  try {
    const { userId } = req.params;

    // è°ƒç”¨ PostgREST è·å–ç”¨æˆ·å®Œæ•´ä¸Šä¸‹æ–‡
    const response = await fetch(
      `${process.env.POSTGREST_URL}/rpc/get_user_context?p_user_id=eq.${userId}`,
      {
        headers: {
          Authorization: req.headers.authorization,
          "Content-Type": "application/json",
        },
      },
    );

    if (!response.ok) {
      throw new Error(`PostgREST error: ${response.statusText}`);
    }

    const userContext = await response.json();

    if (!userContext || userContext.length === 0) {
      return res.status(404).json({
        error: "User context not found",
        code: "USER_CONTEXT_NOT_FOUND",
      });
    }

    res.json(userContext[0]);
  } catch (error) {
    console.error("Get user context error:", error);
    res.status(500).json({
      error: "Failed to get user context",
      details: error.message,
    });
  }
});

// é‡æ–°åŠ è½½é…ç½®åˆ° Redis
router.post("/reload", async (req, res) => {
  try {
    const { config_type, config_id } = req.body;

    // è°ƒç”¨é…ç½®æœåŠ¡é‡æ–°åŠ è½½é…ç½®
    const response = await fetch(`${process.env.CONFIG_SERVICE_URL}/reload`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ config_type, config_id }),
    });

    if (!response.ok) {
      throw new Error(`Config service error: ${response.statusText}`);
    }

    const result = await response.json();

    res.json({
      success: true,
      message: "Configuration reloaded successfully",
      ...result,
    });
  } catch (error) {
    console.error("Reload config error:", error);
    res.status(500).json({
      error: "Failed to reload configuration",
      details: error.message,
    });
  }
});

// è·å–ç³»ç»ŸçŠ¶æ€
router.get("/status", async (req, res) => {
  try {
    const status = {
      service: "neuropia_api_gateway",
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || "development",
      redis: {
        connected: RedisService.client?.isOpen || false,
      },
      config_service: "unknown",
    };

    // æ£€æŸ¥é…ç½®æœåŠ¡çŠ¶æ€
    try {
      const configServiceResponse = await fetch(
        `${process.env.CONFIG_SERVICE_URL}/health`,
      );
      status.config_service = configServiceResponse.ok
        ? "healthy"
        : "unhealthy";
    } catch (error) {
      status.config_service = "unreachable";
    }

    res.json(status);
  } catch (error) {
    console.error("Get status error:", error);
    res.status(500).json({
      error: "Failed to get system status",
      details: error.message,
    });
  }
});

module.exports = router;

```

```js
// neuropia_api_gateway/src/routes/users.js
const express = require("express");
const { UserService } = require("../services/userService");
const router = express.Router();

/**
 * ç”¨æˆ·ç®¡ç†è·¯ç”±
 * æä¾›ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢ã€Virtual Key ç®¡ç†ç­‰åŠŸèƒ½
 */

// è·å–ç”¨æˆ·ä¿¡æ¯
router.get("/:userId", async (req, res) => {
  try {
    const { userId } = req.params;

    const userContext = await UserService.getUserContext(userId);
    if (!userContext) {
      return res.status(404).json({
        success: false,
        error: "User not found",
      });
    }

    res.json({
      success: true,
      data: userContext,
    });
  } catch (error) {
    console.error("Get user error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get user information",
    });
  }
});

// è·å–ç”¨æˆ· Virtual Key åˆ—è¡¨
router.get("/:userId/virtual-keys", async (req, res) => {
  try {
    const { userId } = req.params;

    const virtualKeys = await UserService.getUserVirtualKeys(userId);

    res.json({
      success: true,
      data: virtualKeys,
    });
  } catch (error) {
    console.error("Get user virtual keys error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get virtual keys",
    });
  }
});

// åˆ›å»º Virtual Key
router.post("/:userId/virtual-keys", async (req, res) => {
  try {
    const { userId } = req.params;
    const keyData = req.body;

    // éªŒè¯å¿…è¦å­—æ®µ
    if (!keyData.name) {
      return res.status(400).json({
        success: false,
        error: "Virtual key name is required",
      });
    }

    const virtualKey = await UserService.createVirtualKey(userId, keyData);

    res.json({
      success: true,
      data: {
        virtual_key: virtualKey,
        message: "Virtual key created successfully",
      },
    });
  } catch (error) {
    console.error("Create virtual key error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create virtual key",
    });
  }
});

// è·å–ç”¨æˆ·ä½¿ç”¨ç»Ÿè®¡
router.get("/:userId/usage-stats", async (req, res) => {
  try {
    const { userId } = req.params;
    const { start_date, end_date } = req.query;

    const stats = await UserService.getUserUsageStats(
      userId,
      start_date,
      end_date,
    );

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error("Get usage stats error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get usage statistics",
    });
  }
});

// æ£€æŸ¥ç”¨æˆ·è®¿é—®æƒé™
router.get("/:userId/access", async (req, res) => {
  try {
    const { userId } = req.params;

    const access = await UserService.checkUserAccess(userId);

    res.json({
      success: true,
      data: access,
    });
  } catch (error) {
    console.error("Check user access error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to check user access",
    });
  }
});

// è·å–ç”¨æˆ·ä½™é¢
router.get("/:userId/balance", async (req, res) => {
  try {
    const { userId } = req.params;

    const balance = await UserService.getUserBalance(userId);

    res.json({
      success: true,
      data: balance,
    });
  } catch (error) {
    console.error("Get user balance error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get user balance",
    });
  }
});

module.exports = router;

```

```js
// neuropia_api_gateway/src/services/configService.js
class ConfigService {
    static async getAllConfigs(userContext, requestBody) {
        try {
            console.log('ğŸ”§ è°ƒç”¨ Config Service è·å–å®Œæ•´é…ç½®...', {
                user_id: userContext.user_id,
                virtual_key: userContext.virtual_key,
                model: requestBody.model
            });

            const response = await fetch(
                `${process.env.CONFIG_SERVICE_URL}/generate-config`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userContext: {
                            user_id: userContext.user_id,
                            virtual_key: userContext.virtual_key,
                            tier_name: userContext.tier_name
                        },
                        requestBody: requestBody
                    })
                }
            );

            if (!response.ok) {
                throw new Error(`Config Service å“åº”é”™è¯¯: ${response.status}`);
            }

            const data = await response.json();

            if (!data.success) {
                throw new Error(`Config Service è¿”å›é”™è¯¯: ${data.error}`);
            }

            return data.config; // è¿”å›å®Œæ•´çš„é…ç½®å¯¹è±¡
        } catch (error) {
            console.error('âŒ Failed to get configs:', error.message);
            throw error;
        }
    }

    // ä¿æŒå‘åå…¼å®¹
    static async getPortkeyConfig(userContext, requestBody) {
        const allConfigs = await this.getAllConfigs(userContext, requestBody);
        return { success: true, config: allConfigs };
    }
}

module.exports = { ConfigService };

```

## æ–°è®¾è®¡æ€è·¯

å»æ‰``neuropia_config_service``, å› ä¸ºé…ç½®æå¤§ç®€åŒ–, é€šè¿‡æ•°æ®åº“çš„hierarchyç»“æ„è‡ªåŠ¨å½¢æˆç»§æ‰¿å…³ç³»,  åœ¨``neuropia_api_gateway``ç›´æ¥è¯·æ±‚æ•°æ®åº“è·å–é…ç½®, è½¬å‘ç»™``portkey_gateway``

éœ€è¦ä¸€ä¸ªpgListener:

```js
// neuropia_config_service/src/listeners/pgListener.js
const { Client } = require("pg");
const { ConfigManager } = require("../services/configManager");
const {
  PortkeyConfigGenerator,
} = require("../services/portkeyConfigGenerator");
const redisService = require("@shared/clients/redis");

class PGListener {
  constructor() {
    this.client = null;
    this.listeners = new Map();
  }

  async connect() {
    this.client = new Client({
      connectionString: process.env.DATABASE_URL,
      ssl:
        process.env.NODE_ENV === "production"
          ? { rejectUnauthorized: false }
          : false,
    });

    await this.client.connect();
    console.log("âœ… PostgreSQL listener connected");

    // ğŸ¯ ç›‘å¬æ–°çš„ç»Ÿä¸€é…ç½®æ›´æ–°é¢‘é“
    await this.client.query("LISTEN config_updates");

    // ä¿æŒå¯¹æ—§é¢‘é“çš„å…¼å®¹
    await this.client.query("LISTEN config_update");
    await this.client.query("LISTEN virtual_key_update");

    this.client.on("notification", (msg) => {
      console.log(`ğŸ“¢ Received notification on channel: ${msg.channel}`);
      this.handleNotification(msg);
    });

    this.client.on("error", (err) => {
      console.error("âŒ PostgreSQL listener error:", err);
    });
  }

  handleNotification(msg) {
    try {
      const payload = JSON.parse(msg.payload);

      switch (msg.channel) {
        case "config_updates":
          this.handleConfigUpdate(payload);
          break;
        case "config_update":
          ConfigManager.handleConfigUpdate(payload);
          break;
        case "virtual_key_update":
          ConfigManager.handleVirtualKeyUpdate(payload);
          break;
        default:
          console.log("Unknown notification channel:", msg.channel);
      }
    } catch (error) {
      console.error("âŒ Error handling notification:", error);
    }
  }

  /**
   * ğŸ†• å¤„ç†æ–°çš„ç»Ÿä¸€é…ç½®æ›´æ–°
   */
  async handleConfigUpdate(payload) {
    try {
      console.log("ğŸ”„ Handling config update:", payload);

      const { table, action } = payload;

      switch (table) {
        case "unified_config_store":
          await this.handleUnifiedConfigUpdate(payload);
          break;

        case "tier_feature_mappings":
          await this.handleTierFeatureUpdate(payload);
          break;

        case "inheritance_rules":
        case "config_levels":
          await this.handleStructuralUpdate(payload);
          break;

        case "config_types":
          await this.handleConfigTypeUpdate(payload);
          break;

        default:
          console.warn(`Unknown table in config update: ${table}`);
      }
    } catch (error) {
      console.error("âŒ Failed to handle config update:", error);
    }
  }

  /**
   * å¤„ç† unified_config_store æ›´æ–°
   */
  async handleUnifiedConfigUpdate(payload) {
    const { virtual_key, scope_id } = payload;

    if (virtual_key) {
      // ğŸ¯ æ¸…ç†å…·ä½“è™šæ‹Ÿå¯†é’¥çš„ç¼“å­˜
      const pattern = `portkey_config:*:${virtual_key}:*`;
      const keys = await redisService.keys(pattern);
      if (keys.length > 0) {
        await redisService.del(...keys);
        console.log(
          `ğŸ§¹ Cleared ${keys.length} caches for virtual_key: ${virtual_key}`,
        );
      }
    } else if (scope_id) {
      // å°è¯•ä½¿ç”¨ scope_id ä½œä¸º virtual_key
      const pattern = `portkey_config:*:${scope_id}:*`;
      const keys = await redisService.keys(pattern);
      if (keys.length > 0) {
        await redisService.del(...keys);
        console.log(
          `ğŸ§¹ Cleared ${keys.length} caches for scope_id: ${scope_id}`,
        );
      }
    } else {
      // ğŸ¯ ä¿å®ˆç­–ç•¥ï¼šæ¸…ç†æ‰€æœ‰ç¼“å­˜
      await this.clearAllConfigCache();
    }
  }

  /**
   * å¤„ç† tier_feature_mappings æ›´æ–°
   */
  async handleTierFeatureUpdate(payload) {
    const { tier_name } = payload;

    if (tier_name) {
      // ğŸ¯ æ¸…ç†è¯¥å¥—é¤çš„æ‰€æœ‰ç”¨æˆ·ç¼“å­˜
      const pattern = `portkey_config:*:*:${tier_name}:*`;
      const keys = await redisService.keys(pattern);
      if (keys.length > 0) {
        await redisService.del(...keys);
        console.log(`ğŸ° Cleared ${keys.length} caches for tier: ${tier_name}`);
      }
    } else {
      // ğŸ¯ ä¿å®ˆç­–ç•¥ï¼šæ¸…ç†æ‰€æœ‰ç¼“å­˜
      await this.clearAllConfigCache();
    }
  }

  /**
   * å¤„ç†ç»“æ„å˜æ›´ï¼ˆç»§æ‰¿è§„åˆ™ã€å±‚çº§ï¼‰
   */
  async handleStructuralUpdate(payload) {
    // ğŸ¯ ç»“æ„å˜æ›´å½±å“æ‰€æœ‰é…ç½®ï¼Œæ¸…ç†æ‰€æœ‰ç¼“å­˜
    await this.clearAllConfigCache();
    console.log("ğŸŒ Structural change - cleared all config caches");
  }

  /**
   * å¤„ç†é…ç½®ç±»å‹æ›´æ–°
   */
  async handleConfigTypeUpdate(payload) {
    const { type_name } = payload;

    if (type_name) {
      // ğŸ¯ æ¸…ç†è¯¥é…ç½®ç±»å‹çš„æ‰€æœ‰ç¼“å­˜
      const pattern = `config_resolution:${type_name}:*`;
      const keys = await redisService.keys(pattern);
      if (keys.length > 0) {
        await redisService.del(...keys);
        console.log(
          `ğŸ“ Cleared ${keys.length} caches for config_type: ${type_name}`,
        );
      }
    } else {
      // ğŸ¯ ä¿å®ˆç­–ç•¥ï¼šæ¸…ç†æ‰€æœ‰é…ç½®è§£æç¼“å­˜
      const pattern = `config_resolution:*`;
      const keys = await redisService.keys(pattern);
      if (keys.length > 0) {
        await redisService.del(...keys);
        console.log(`ğŸ“ Cleared all config resolution caches`);
      }
    }
  }

  /**
   * æ¸…ç†æ‰€æœ‰é…ç½®ç¼“å­˜
   */
  async clearAllConfigCache() {
    const portkeyKeys = await redisService.keys("portkey_config:*");
    const configResolutionKeys = await redisService.keys("config_resolution:*");

    const allKeys = [...portkeyKeys, ...configResolutionKeys];

    if (allKeys.length > 0) {
      await redisService.del(...allKeys);
      console.log(`ğŸŒ Cleared all ${allKeys.length} config caches`);
    }
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  emit(event, data) {
    const callbacks = this.listeners.get(event) || [];
    callbacks.forEach((callback) => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in event listener for ${event}:`, error);
      }
    });
  }

  async disconnect() {
    if (this.client) {
      await this.client.end();
      console.log("PostgreSQL listener disconnected");
    }
  }
}

module.exports = new PGListener();

```

å°è£…å¥½çš„ä¸¤ä¸ªclients:

```js
// neuropia_config_service/src/clients/postgrest.js
const { PostgrestClient } = require('@supabase/postgrest-js');

// ç›´æ¥ä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„å›ºå®štoken
const postgrestToken = process.env.POSTGREST_TOKEN;

if (!postgrestToken) {
  throw new Error('POSTGREST_TOKEN environment variable is required');
}

// ç›´æ¥å¯¼å‡ºé…ç½®å¥½çš„å®¢æˆ·ç«¯å®ä¾‹
module.exports = new PostgrestClient(
  process.env.POSTGREST_URL || 'http://localhost:3000',
  {
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'Authorization': `Bearer ${postgrestToken}`
    }
  }
);

```

```js
// src/services/redisService.js
/*
ç¼“å­˜ç­–ç•¥è¯´æ˜
æ°¸ä¹…ç¼“å­˜ï¼ˆä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼‰ï¼š
virtual_key:{key} - Virtual Key é…ç½®ï¼ˆå˜æ›´æ—¶æ‰‹åŠ¨åˆ é™¤ï¼‰
portkey_config:{id} - Portkey é…ç½®ï¼ˆå˜æ›´æ—¶æ‰‹åŠ¨åˆ é™¤ï¼‰

æœ‰æ—¶æ•ˆçš„ç¼“å­˜ï¼š
provider_rates - æä¾›å•†è´¹ç‡ï¼ˆ1å°æ—¶è¿‡æœŸï¼‰
usage:{key} - ä½¿ç”¨é‡ç»Ÿè®¡ï¼ˆ24å°æ—¶è¿‡æœŸï¼‰
 */
const redis = require("redis");
const postgrestClient = require("./postgrest");

class RedisService {
  constructor() {
    this.client = null;
  }

  async get(key) {
    try {
      return await this.client.get(key);
    } catch (error) {
      console.error(`âŒ Redis get error for key ${key}:`, error);
      return null;
    }
  }

  async keys(pattern) {
    try {
      return await this.client.keys(pattern);
    } catch (error) {
      console.error(`âŒ Redis keys error for pattern ${pattern}:`, error);
      return [];
    }
  }

  async del(...keys) {
    try {
      return await this.client.del(keys);
    } catch (error) {
      console.error(`âŒ Redis del error for keys ${keys}:`, error);
      return 0;
    }
  }

  async setex(key, seconds, value) {
    try {
      await this.client.setEx(key, seconds, value);
      return true;
    } catch (error) {
      console.error(`âŒ Redis setex error for key ${key}:`, error);
      return false;
    }
  }

  async connect() {
    this.client = redis.createClient({
      url: process.env.REDIS_URL || "redis://localhost:6379",
    });

    this.client.on("error", (err) => console.error("Redis Client Error", err));
    await this.client.connect();
    console.log("Connected to Redis");
  }

  // ğŸŸ¢ Virtual Key ç›¸å…³æ–¹æ³•
  async cacheVirtualKey(virtualKey, config) {
    const key = `virtual_key:${virtualKey}`;
    // ğŸŸ¢ ä¿®å¤ï¼šä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œé…ç½®å˜æ›´æ—¶æ‰‹åŠ¨åˆ é™¤
    await this.client.set(key, JSON.stringify(config));
    console.log(`Cached virtual key: ${virtualKey}`);
  }

  async getVirtualKey(virtualKey) {
    try {
      const key = `virtual_key:${virtualKey}`;

      // 1. å…ˆå°è¯•ä»Redisè·å–
      const data = await this.client.get(key);
      if (data) {
        console.log(`ğŸ“¦ Redisç¼“å­˜å‘½ä¸­: ${virtualKey}`);
        const parsed = JSON.parse(data);
        console.log("ğŸ“Š ç¼“å­˜æ•°æ®:", parsed); // ğŸ¯ æ£€æŸ¥ç¼“å­˜æ•°æ®ç»“æ„
        return parsed;
      }

      // 2. ç¼“å­˜æ²¡å‘½ä¸­ï¼Œå»æ•°æ®åº“æŸ¥è¯¢
      console.log(`ğŸ” ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“: ${virtualKey}`);
      const vkConfig = await this.fetchVirtualKeyFromDB(virtualKey);

      console.log("ğŸ“Š æ•°æ®åº“æŸ¥è¯¢ç»“æœ:", vkConfig); // ğŸ¯ æ£€æŸ¥æ•°æ®åº“æ•°æ®ç»“æ„

      if (vkConfig) {
        // ğŸ¯ éªŒè¯æ•°æ®ç»“æ„
        if (!vkConfig.user_id || vkConfig.is_active === undefined) {
          console.error("âŒ æ•°æ®åº“è¿”å›çš„æ•°æ®ç»“æ„ä¸å®Œæ•´:", vkConfig);
        }

        // 3. å¼‚æ­¥ç¼“å­˜ç»“æœ
        this.client
          .set(key, JSON.stringify(vkConfig), { ex: 300 })
          .then(() => console.log(`ğŸ’¾ ç¼“å­˜virtual_key: ${virtualKey}`))
          .catch((err) => console.warn("ç¼“å­˜å†™å…¥å¤±è´¥:", err));
      }

      return vkConfig;
    } catch (error) {
      console.error("RedisService.getVirtualKey error:", error);
      return await this.fetchVirtualKeyFromDB(virtualKey);
    }
  }

  async fetchVirtualKeyFromDB(virtualKey) {
    try {
      const { data, error, status } = await postgrestClient
        .from("virtual_keys")
        .select("user_id, virtual_key, is_active")
        .eq("virtual_key", virtualKey);

      if (error) {
        console.error(`æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: ${status}`, error.message);
        return null;
      }

      return data?.[0] || null;
    } catch (err) {
      console.error("æ•°æ®åº“æŸ¥è¯¢å¼‚å¸¸:", err);
      return null;
    }
  }

  async deleteVirtualKey(virtualKey) {
    const key = `virtual_key:${virtualKey}`;
    await this.client.del(key);
    console.log(`Deleted virtual key from cache: ${virtualKey}`);
  }

  // ğŸŸ¢ Portkey é…ç½®ç›¸å…³æ–¹æ³•
  async cachePortkeyConfig(configId, configJson) {
    const key = `portkey_config:${configId}`;
    // ğŸŸ¢ ä¿®å¤ï¼šä¸è®¾ç½®è¿‡æœŸæ—¶é—´
    await this.client.set(key, JSON.stringify(configJson));
    console.log(`Cached portkey config: ${configId}`);
  }

  async getPortkeyConfig(configId) {
    const key = `portkey_config:${configId}`;
    const data = await this.client.get(key);
    return data ? JSON.parse(data) : null;
  }

  async deletePortkeyConfig(configId) {
    const key = `portkey_config:${configId}`;
    await this.client.del(key);
    console.log(`Deleted portkey config from cache: ${configId}`);
  }

  // ğŸŸ¢ æä¾›å•†è´¹ç‡ï¼ˆå¯ä»¥è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œå› ä¸ºå˜åŒ–ä¸é¢‘ç¹ï¼‰
  async cacheProviderRates(rates) {
    await this.client.set("provider_rates", JSON.stringify(rates), {
      EX: 3600, // 1å°æ—¶è¿‡æœŸï¼Œè´¹ç‡å˜åŒ–ä¸é¢‘ç¹
    });
  }

  async getProviderRates() {
    const data = await this.client.get("provider_rates");
    return data ? JSON.parse(data) : [];
  }

  // ğŸŸ¢ ä½¿ç”¨é‡ç»Ÿè®¡ï¼ˆéœ€è¦è¿‡æœŸæ—¶é—´ï¼Œé¿å…æ— é™å¢é•¿ï¼‰
  async incrementVirtualKeyUsage(virtualKey, tokensUsed = 0) {
    const key = `usage:${virtualKey}`;
    await this.client
      .multi()
      .hIncrBy(key, "request_count", 1)
      .hIncrBy(key, "token_count", tokensUsed)
      .hSet(key, "last_used", new Date().toISOString())
      .expire(key, 86400) // 24å°æ—¶è¿‡æœŸ
      .exec();
  }

  // ğŸŸ¢ æ–°å¢ï¼šæ‰¹é‡åˆ é™¤ï¼ˆç”¨äºæœåŠ¡é‡å¯æˆ–æ¸…ç†ï¼‰
  async clearAllConfigs() {
    const configKeys = await this.client.keys("portkey_config:*");
    const virtualKeys = await this.client.keys("virtual_key:*");

    if (configKeys.length > 0) {
      await this.client.del(configKeys);
    }
    if (virtualKeys.length > 0) {
      await this.client.del(virtualKeys);
    }

    console.log(
      `Cleared ${configKeys.length} portkey configs and ${virtualKeys.length} virtual keys`,
    );
  }
}

module.exports = new RedisService();

```

## api_gateway çš„ç”¨é‡ç»Ÿè®¡

å‚è§portkey gatewayçš„è¯´æ˜, api_gateway è¯·æ±‚portkey gatewayè¿”å›çš„å“åº”ä¸­åŒ…å«å¯ç»Ÿè®¡, è®¡é‡ä¿¡æ¯. api_gateway åº”è¯¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§å®ç°ç›¸åº”åŠŸèƒ½.

