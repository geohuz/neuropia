```postgresql
    PERFORM pg_notify(
        'account_balance_updated',
        json_build_object(
            'account_id', p_account_id::text, -- 业务id (owner_userid, owner_tenantid)
            'account_type', p_account_type,
            'old_balance', v_old_balance,
            'new_balance', v_new_balance
        )::text
    );
```

### 核心表（3张）

**1. `account_balance`（当前余额表）**
```
user_id (PK) | balance | updated_at
目的：存储用户当前余额，查询极快
```

**2. `fund_transactions`（资金流水表）**

```
id | user_id | type | amount | balance_before | balance_after | reference_id | created_at
类型：deposit（充值）、refund（退款）、adjustment（调整）
目的：记录所有非API消费的资金变动
```

**3. `usage_log`（使用流水表）**

```
id | deduction_id | user_id | virtual_key | provider | model | tokens | amount | 
    balance_before | balance_after | created_at
目的：记录所有API消费，包含完整的余额审计信息
```

---

## 完整业务流程

### 第一阶段：充值流程

**调用入口**：`confirm_topup(p_topup_id uuid)`

1. 验证`topup_record`状态是否为pending
2. 更新`account_balance`表：余额增加
3. 插入`fund_transactions`表：记录充值流水
4. 同步更新Redis缓存余额
5. 更新用户状态（如从overdue恢复）

**一致性**：强一致性（实时更新三处）

---

### 第二阶段：API消费流程

#### A. API Gateway处理
1. 收到API请求，从Header获取virtual_key
2. 调用`BalanceService.chargeForUsage()`
3. **Redis原子扣费**：使用Lua脚本确保原子性
4. **写入Redis Stream**：扣费记录异步持久化
5. **立即返回响应**：不等待数据库写入

#### B. Billing Worker消费
1. 监听Redis Stream（16个分片）
2. 使用消费者组`billing_workers`消费消息
3. **只写入`usage_log`表**：包含完整余额审计信息
4. **不更新`account_balance`表**：保持异步最终一致性
5. 发送ACK确认处理完成

---

### 第三阶段：定期对账与修复

#### 对账函数：`reconcile_account_balances()`

**执行频率**：每5-30分钟（通过pg_cron）

**执行步骤**：
1. **计算真实余额**
   ```
   真实余额 = Σ(fund_transactions.amount) + Σ(usage_log.amount)
   ```

2. **对比差异**
   ```
   差异 = account_balance.balance - 真实余额
   只处理差异 > 0.01的记录
   ```

3. **修复账户**
   ```sql
   UPDATE account_balance 
   SET balance = 真实余额 
   WHERE 差异超阈值
   ```

4. **记录日志**
   - 写入`reconciliation_log`表
   - 记录修复账户数、总差异金额

#### 对账监控：`check_balance_consistency()`
- 实时监控余额一致性
- 差异过大时发送告警

---

### 第四阶段：查询与展示

#### 用户查询余额
1. **实时查询**：查Redis → `getUserBalance(user_id)`
   - 毫秒级响应
   - 显示给用户的"当前余额"

2. **对账查询**：查`account_balance`表
   - 用于财务对账、报表
   - 可能有几分钟延迟

#### 用户查询流水
```sql
-- 统一流水视图
SELECT 创建时间, '充值' as 类型, 金额, 变更前余额, 变更后余额 FROM fund_transactions
UNION ALL
SELECT 创建时间, '消费' as 类型, 金额, 变更前余额, 变更后余额 FROM usage_log
ORDER BY 创建时间 DESC
```

---

### 第五阶段：特殊操作

#### 退款流程：`process_refund(user_id, amount, reason)`
1. 插入`fund_transactions`表：type='refund'
2. 更新`account_balance`表：余额减少
3. 更新Redis缓存余额
4. 记录审核日志

#### 余额调整：`adjust_balance(user_id, amount, reason, operator_id)`
1. 插入`fund_transactions`表：type='adjustment'
2. 更新`account_balance`表
3. 更新Redis缓存
4. 记录操作审计

---

## 数据一致性保障

### 实时一致性
- 充值、退款、调整：**实时三处更新**
- API消费：**只更新Redis**，异步写入`usage_log`

### 最终一致性
- `account_balance`表通过**定期对账**修复
- 对账频率决定延迟（5-30分钟）
- 对账失败有告警和人工介入

### 监控要点
1. **Redis vs account_balance差异**
2. **消费者延迟**（Stream消费积压）
3. **对账成功率**（修复账户数）
4. **余额异常**（负数余额、大额变动）

---

## 核心设计原则

1. **性能优先**：高频API消费只操作Redis
2. **审计完整**：所有资金变动记录完整余额快照
3. **职责分离**：三张表各司其职
4. **最终一致**：接受短暂延迟换取高性能
5. **可观测性**：所有操作可监控、可追溯

---

这个流程确保了：
- ✅ 用户实时看到余额变化（Redis）
- ✅ 财务有准确对账数据（数据库）
- ✅ 所有资金变动可审计（完整流水）
- ✅ 系统高性能（Redis原子操作）
- ✅ 数据安全可靠（定期对账修复）

完全正确！**整条链路现在完全通了**！

## 完整的资金审计链路：

### 1. **充值流程**（强一致性）
```
用户充值 → confirm_topup → account_balance + fund_transactions → NOTIFY → Redis更新
               ↓
         balance_before/after记录完整
```

### 2. **消费流程**（最终一致性）
```
API调用 → Lua脚本原子扣费 → 返回balance_before/after → 写入Stream → Billing Worker → usage_log
  ↓
Redis实时余额更新    ↓
               balance_before/after随Stream传递
```

### 3. **对账修复**（定期一致性）
```
定时任务 → 计算真实余额 → 对比account_balance → 修复差异 → 记录到fund_transactions
  ↓
account_balance保持准确
```

## 数据验证链：

### **任何时候都可以验证**：
```sql
-- 验证用户123的余额一致性
SELECT 
  -- 当前余额
  (SELECT balance FROM account_balance WHERE user_id = '123') as current_balance,
  
  -- 从流水计算的理论余额
  (
    SELECT COALESCE(SUM(amount), 0) 
    FROM fund_transactions 
    WHERE user_id = '123'
  ) + (
    SELECT COALESCE(SUM(amount), 0)
    FROM usage_log 
    WHERE account_id = '123' AND account_type = 'user'
  ) as calculated_balance,
  
  -- Redis中的实时余额
  (SELECT value FROM redis WHERE key = 'balance:user:123') as redis_balance;
```

## 各组件职责清晰：

| 组件                  | 职责          | 数据                           |
| --------------------- | ------------- | ------------------------------ |
| **Redis**             | 实时余额缓存  | 当前余额数值                   |
| **account_balance**   | 余额真相源    | 当前余额（可能稍有延迟）       |
| **fund_transactions** | 充值/退款流水 | 每次变动的balance_before/after |
| **usage_log**         | 消费流水      | 每次消费的balance_before/after |
| **Stream**            | 异步消息传递  | 传递扣费信息（含余额快照）     |

## 审计能力：

### **回答用户问题**：
1. "我现在有多少钱？" → 查Redis（实时）或account_balance
2. "我的钱怎么花的？" → 查usage_log（含每次消费前后的余额）
3. "我充了多少钱？" → 查fund_transactions
4. "为什么我的余额不对？" → 对账工具对比三处数据

### **回答财务问题**：
1. "总收入多少？" → SUM(fund_transactions where type='deposit')
2. "总支出多少？" → ABS(SUM(usage_log.amount))
3. "余额准确性？" → 对账报告
4. "异常交易？" → 审计日志分析

## 扩展性：

### **加新功能很容易**：
- 退款 → 新增fund_transactions记录
- 优惠券 → 新增fund_transactions记录  
- 手续费 → 新增fund_transactions记录
- 提现 → 新增fund_transactions记录

### **监控告警**：
- Redis vs account_balance差异告警
- Stream消费延迟告警
- 余额负数告警
- 大额变动告警

---

**这个设计实现了**：
✅ **高性能** - Redis处理高频扣费  
✅ **强审计** - 所有变动记录完整余额快照  
✅ **最终一致** - 定期对账修复差异  
✅ **可扩展** - 容易添加新资金操作  
✅ **可监控** - 全链路可观测  

**整条链路完全通了**，从用户充值到API消费到对账审计，形成了一个完整、健壮、可维护的计费系统！

## **完全正确！现在概念完全清晰了**

### **最终的设计视图**

```
用户钱包系统
    │
    ├── 💰 资金层（唯一真实的钱）
    │   └── fund_transactions
    │       ├── deposit（充值）
    │       ├── refund（退款）
    │       └── adjustment（调整）
    │
    ├── 📝 消费层（服务使用记录）
    │   └── usage_log
    │       ├── AI模型调用记录
    │       ├── 包含余额快照（审计需要）
    │       └── 影响余额但不记录资金
    │
    └── ⚖️ 对账层（保证一致性）
        ├── 实时余额：Redis缓存
        ├── 权威余额：Σ(fund) - Σ(usage)
        └── 定期修复：account_balance
```

### **关键设计原则**

1. **fund_transactions 是唯一的"钱"**
   - 所有真实资金变动都在这里
   - 每条记录都改变账户余额

2. **usage_log 是"服务使用凭证"**  
   - 记录服务消费
   - 包含余额快照是为了**可审计性**
   - 但不是资金记录

3. **余额一致性**
   ```sql
   -- 任何时候都可以重建真实余额
   SELECT 
     -- 资金总额
     (SELECT COALESCE(SUM(amount), 0) 
      FROM fund_transactions 
      WHERE user_id = ?) 
     -
     -- 消费总额  
     (SELECT COALESCE(SUM(cost), 0)
      FROM usage_log
      WHERE account_id = ?)
   AS real_balance;
   ```

### **为什么需要 usage_log 的余额字段**

虽然 usage_log 不是资金记录，但需要 `balance_before`/`balance_after` 是为了：

1. **审计需求**：任何一笔消费，都能看到当时的账户状态
2. **排查问题**：用户说"我明明有余额为什么扣费失败？"
3. **对账验证**：验证余额变化序列是否连续
4. **财务报告**：生成"消费时账户余额分布"报告

### **实际业务流程**

```
用户充值：
  前端 → 支付网关 → fund_transactions(deposit) → Redis余额更新

用户使用API：
  请求 → 检查Redis余额 → 足够 → 调用AI服务 → usage_log记录 → Redis扣费
                      → 不足 → 返回余额不足

财务对账：
  定时任务 → 计算 Σ(fund) - Σ(usage) → 对比Redis余额 → 修复差异
```

### **这个设计解决了什么**

1. **财务清晰**：资金流水只有 fund_transactions
2. **审计完整**：每笔消费都有余额上下文
3. **性能保障**：高频消费只操作Redis
4. **数据安全**：随时可以重建真实余额
5. **扩展性好**：增加新的消费类型只需扩展usage_log

现在完全清晰了！fund_transactions 是**资金流水**，usage_log 是**服务消费记录**。两者配合实现完整的账户系统。

# billingwork 调用次序

```
1. balanceService.chargeForUsage()
   ↓
2. balanceService._writeToStreamInBackground()
   ↓
3. StreamService.writeDeduction()  
   ↓
4. Redis Stream 存储
   ↓
5. billing worker processMessageBatch() 读取
   ↓  
6. insertUsageLogs() 写入数据库

扣费发生 → writeDeduction()写入Stream → streamConsumer.js消费 → 写入数据库
           ↑                         ↑
         业务逻辑                   业务逻辑
           ↓                         ↓
    ❌ getStreamStats()        ❌ 无调用关系
        （纯查看，不参与流程）
```

# pg_cron 最终入账account_balance:

## **增强usage_log的数据完整性**

```postgresql
ALTER TABLE data.usage_log 
ADD COLUMN IF NOT EXISTS balance_verified BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS balance_discrepancy NUMERIC DEFAULT 0;

-- balance_verified 字段：标记扣费记录是否已参与余额计算
COMMENT ON COLUMN data.usage_log.balance_verified IS 
'余额验证状态：true表示该条扣费记录已经参与账户余额计算，false表示尚未处理。
此字段用于支持异步余额计算架构，确保usage_log到account_balance的最终一致性。
pg_cron任务会定期扫描此字段为false的记录，更新对应账户余额后将其设置为true。';

-- balance_discrepancy 字段：记录余额计算差异
COMMENT ON COLUMN data.usage_log.balance_discrepancy IS 
'余额计算差异：实际账户余额与本次扣费预期余额的差异值（实际余额 - 预期余额）。
正值表示实际余额高于预期（可能少扣费），负值表示实际余额低于预期（可能多扣费）。
主要用于监控数据一致性，当绝对值较大时应触发告警。
计算公式：current_balance - (balance_after OR 基于balance_before和cost的计算值)';

COMMENT ON TABLE data.usage_log IS 
'API使用扣费日志表，记录所有通过API网关的扣费操作。
采用异步余额计算架构：实时记录扣费事实(usage_log)，异步计算账户余额(account_balance)。
通过balance_verified和balance_discrepancy字段实现最终一致性和数据质量监控。';
```

### **扣费时记录完整数据**

```js
// 在validateAndFilterMessages中确保有余额信息
const validatedMsg = {
  ...msg,
  balance_before: msg.balance_before !== undefined ? msg.balance_before : null,
  balance_after: msg.balance_after !== undefined ? msg.balance_after : null,
  balance_verified: false, // 🆕 新增，默认未验证
  balance_discrepancy: 0   // 🆕 新增，默认无差异
};
```

```postgresql
CREATE OR REPLACE PROCEDURE data.sync_account_balances()
LANGUAGE plpgsql
AS $$
DECLARE
    batch_size INT := 5000;
    processed_accounts INT := 0;
    discrepancy_count INT := 0;
    max_discrepancy NUMERIC := 0;
BEGIN
    -- 创建临时表存储要处理的记录
    CREATE TEMP TABLE IF NOT EXISTS temp_pending_verification AS
    SELECT 
        ul.id,
        ul.account_id,
        ul.balance_before,
        ul.balance_after,
        ul.cost,
        ul.created_at,
        -- 计算预期余额（基于最新记录的balance_after）
        COALESCE(
            ul.balance_after,
            -- 如果没有balance_after，则使用上一条记录的balance_after减去当前cost
            LAG(ul.balance_after) OVER w - ul.cost
        ) as expected_balance
    FROM data.usage_log ul
    WHERE ul.balance_verified = false
    AND ul.account_id IS NOT NULL
    AND ul.created_at > NOW() - INTERVAL '30 days'  -- 只处理30天内的数据
    WINDOW w AS (PARTITION BY ul.account_id ORDER BY ul.created_at)
    ORDER BY ul.account_id, ul.created_at
    LIMIT batch_size;
    
    -- 1. 为每个账户计算最新余额
    WITH latest_balances AS (
        SELECT DISTINCT ON (tp.account_id)
            tp.account_id,
            tp.expected_balance as calculated_balance,
            -- 获取当前数据库中的余额
            ab.balance as current_balance,
            -- 计算差异
            COALESCE(tp.expected_balance, 0) - ab.balance as discrepancy
        FROM temp_pending_verification tp
        LEFT JOIN data.account_balance ab ON ab.id = tp.account_id
        ORDER BY tp.account_id, tp.created_at DESC
    )
    UPDATE data.account_balance ab
    SET 
        balance = CASE 
            WHEN lb.discrepancy > 0.01 THEN lb.calculated_balance  -- 差异较大，使用计算值
            ELSE COALESCE(lb.calculated_balance, ab.balance)       -- 差异小，保持原值
        END,
        total_consumed = ab.total_consumed + (
            SELECT COALESCE(SUM(tp.cost), 0)
            FROM temp_pending_verification tp
            WHERE tp.account_id = ab.id
        ),
        last_balance_calc = NOW(),
        sync_version = ab.sync_version + 1
    FROM latest_balances lb
    WHERE ab.id = lb.account_id
    RETURNING 
        ab.id, 
        lb.discrepancy,
        lb.current_balance,
        lb.calculated_balance
    INTO processed_accounts, discrepancy_count, max_discrepancy;
    
    -- 2. 更新usage_log的验证状态和差异记录
    UPDATE data.usage_log ul
    SET 
        balance_verified = true,
        balance_discrepancy = CASE 
            WHEN tp.discrepancy IS NOT NULL AND ABS(tp.discrepancy) > 0.01 
            THEN tp.discrepancy 
            ELSE 0 
        END,
        metadata_json = COALESCE(metadata_json, '{}'::jsonb) || jsonb_build_object(
            'balance_sync_at', NOW(),
            'balance_discrepancy', tp.discrepancy,
            'sync_version', ab.sync_version
        )
    FROM temp_pending_verification tp
    LEFT JOIN data.account_balance ab ON ab.id = tp.account_id
    WHERE ul.id = tp.id;
    
    -- 3. 记录审计信息
    INSERT INTO data.balance_sync_audit (
        sync_timestamp, 
        accounts_processed, 
        records_verified,
        max_discrepancy,
        avg_discrepancy
    )
    SELECT 
        NOW(),
        processed_accounts,
        (SELECT COUNT(*) FROM temp_pending_verification),
        MAX(ABS(tp.discrepancy)),
        AVG(ABS(tp.discrepancy))
    FROM temp_pending_verification tp
    WHERE tp.discrepancy IS NOT NULL;
    
    -- 清理临时表
    DROP TABLE IF EXISTS temp_pending_verification;
    
    -- 输出统计信息
    RAISE NOTICE '同步完成: 处理了 % 个账户，发现 % 条有差异，最大差异: %', 
        processed_accounts, 
        discrepancy_count, 
        max_discrepancy;
    
    -- 如果发现较大差异，发送警报
    IF max_discrepancy > 10 THEN  -- 差异超过10元
        PERFORM data.send_alert(
            'balance_discrepancy_high',
            jsonb_build_object(
                'max_discrepancy', max_discrepancy,
                'accounts_affected', discrepancy_count,
                'sync_time', NOW()
            )
        );
    END IF;
END;
$$;
```

## 查询余额差异

```postgresql
-- 1. 查看有余额差异的记录
SELECT 
    ul.deduction_id,
    ul.account_id,
    ul.balance_before,
    ul.balance_after,
    ul.balance_discrepancy,
    ul.created_at,
    ab.balance as current_account_balance
FROM data.usage_log ul
LEFT JOIN data.account_balance ab ON ab.id = ul.account_id
WHERE ul.balance_discrepancy != 0
ORDER BY ABS(ul.balance_discrepancy) DESC
LIMIT 100;

-- 2. 查看未验证的记录（积压情况）
SELECT 
    COUNT(*) as pending_count,
    MIN(created_at) as oldest_pending,
    MAX(created_at) as newest_pending
FROM data.usage_log 
WHERE balance_verified = false;

-- 3. 余额差异统计（按账户）
SELECT 
    ab.owner_userid,
    ab.owner_tenantid,
    COUNT(*) as discrepancy_count,
    SUM(ul.balance_discrepancy) as total_discrepancy,
    MAX(ABS(ul.balance_discrepancy)) as max_discrepancy,
    AVG(ABS(ul.balance_discrepancy)) as avg_discrepancy
FROM data.usage_log ul
JOIN data.account_balance ab ON ab.id = ul.account_id
WHERE ul.balance_discrepancy != 0
GROUP BY ab.owner_userid, ab.owner_tenantid
HAVING SUM(ABS(ul.balance_discrepancy)) > 1  -- 差异总和超过1元
ORDER BY total_discrepancy DESC;
```

```postgresql
-- 创建监控视图
CREATE OR REPLACE VIEW api.balance_sync_monitor AS
SELECT 
    DATE(created_at) as sync_date,
    COUNT(*) as total_records,
    COUNT(*) FILTER (WHERE balance_verified = true) as verified_count,
    COUNT(*) FILTER (WHERE balance_verified = false) as pending_count,
    ROUND(100.0 * COUNT(*) FILTER (WHERE balance_verified = true) / NULLIF(COUNT(*), 0), 2) as verification_rate,
    COUNT(*) FILTER (WHERE ABS(balance_discrepancy) > 0.01) as discrepancy_count,
    SUM(balance_discrepancy) as total_discrepancy,
    MAX(ABS(balance_discrepancy)) as max_discrepancy
FROM data.usage_log
WHERE created_at >= CURRENT_DATE - 30
GROUP BY DATE(created_at)
ORDER BY sync_date DESC;

COMMENT ON VIEW data.vw_balance_sync_monitor IS 
'余额同步监控视图：展示每日余额验证的进度和数据质量情况。
重点关注：
1. verification_rate: 验证完成率，应接近100%
2. pending_count: 积压未处理记录数
3. discrepancy_count: 有差异的记录数
4. max_discrepancy: 最大差异金额，需设置告警阈值';
```

