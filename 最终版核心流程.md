```postgresql
    PERFORM pg_notify(
        'account_balance_updated',
        json_build_object(
            'account_id', p_account_id::text, -- 业务id (owner_userid, owner_tenantid)
            'account_type', p_account_type,
            'old_balance', v_old_balance,
            'new_balance', v_new_balance
        )::text
    );
```

## 全流程总结

### 核心表（3张）

**1. `account_balance`（当前余额表）**
```
user_id (PK) | balance | updated_at
目的：存储用户当前余额，查询极快
```

**2. `fund_transactions`（资金流水表）**

```
id | user_id | type | amount | balance_before | balance_after | reference_id | created_at
类型：deposit（充值）、refund（退款）、adjustment（调整）
目的：记录所有非API消费的资金变动
```

**3. `usage_log`（使用流水表）**

```
id | deduction_id | user_id | virtual_key | provider | model | tokens | amount | 
    balance_before | balance_after | created_at
目的：记录所有API消费，包含完整的余额审计信息
```

---

## 完整业务流程

### 第一阶段：充值流程

**调用入口**：`confirm_topup(p_topup_id uuid)`

1. 验证`topup_record`状态是否为pending
2. 更新`account_balance`表：余额增加
3. 插入`fund_transactions`表：记录充值流水
4. 同步更新Redis缓存余额
5. 更新用户状态（如从overdue恢复）

**一致性**：强一致性（实时更新三处）

---

### 第二阶段：API消费流程

#### A. API Gateway处理
1. 收到API请求，从Header获取virtual_key
2. 调用`BalanceService.chargeForUsage()`
3. **Redis原子扣费**：使用Lua脚本确保原子性
4. **写入Redis Stream**：扣费记录异步持久化
5. **立即返回响应**：不等待数据库写入

#### B. Billing Worker消费
1. 监听Redis Stream（16个分片）
2. 使用消费者组`billing_workers`消费消息
3. **只写入`usage_log`表**：包含完整余额审计信息
4. **不更新`account_balance`表**：保持异步最终一致性
5. 发送ACK确认处理完成

---

### 第三阶段：定期对账与修复

#### 对账函数：`reconcile_account_balances()`

**执行频率**：每5-30分钟（通过pg_cron）

**执行步骤**：
1. **计算真实余额**
   ```
   真实余额 = Σ(fund_transactions.amount) + Σ(usage_log.amount)
   ```

2. **对比差异**
   ```
   差异 = account_balance.balance - 真实余额
   只处理差异 > 0.01的记录
   ```

3. **修复账户**
   ```sql
   UPDATE account_balance 
   SET balance = 真实余额 
   WHERE 差异超阈值
   ```

4. **记录日志**
   - 写入`reconciliation_log`表
   - 记录修复账户数、总差异金额

#### 对账监控：`check_balance_consistency()`
- 实时监控余额一致性
- 差异过大时发送告警

---

### 第四阶段：查询与展示

#### 用户查询余额
1. **实时查询**：查Redis → `getUserBalance(user_id)`
   - 毫秒级响应
   - 显示给用户的"当前余额"

2. **对账查询**：查`account_balance`表
   - 用于财务对账、报表
   - 可能有几分钟延迟

#### 用户查询流水
```sql
-- 统一流水视图
SELECT 创建时间, '充值' as 类型, 金额, 变更前余额, 变更后余额 FROM fund_transactions
UNION ALL
SELECT 创建时间, '消费' as 类型, 金额, 变更前余额, 变更后余额 FROM usage_log
ORDER BY 创建时间 DESC
```

---

### 第五阶段：特殊操作

#### 退款流程：`process_refund(user_id, amount, reason)`
1. 插入`fund_transactions`表：type='refund'
2. 更新`account_balance`表：余额减少
3. 更新Redis缓存余额
4. 记录审核日志

#### 余额调整：`adjust_balance(user_id, amount, reason, operator_id)`
1. 插入`fund_transactions`表：type='adjustment'
2. 更新`account_balance`表
3. 更新Redis缓存
4. 记录操作审计

---

## 数据一致性保障

### 实时一致性
- 充值、退款、调整：**实时三处更新**
- API消费：**只更新Redis**，异步写入`usage_log`

### 最终一致性
- `account_balance`表通过**定期对账**修复
- 对账频率决定延迟（5-30分钟）
- 对账失败有告警和人工介入

### 监控要点
1. **Redis vs account_balance差异**
2. **消费者延迟**（Stream消费积压）
3. **对账成功率**（修复账户数）
4. **余额异常**（负数余额、大额变动）

---

## 核心设计原则

1. **性能优先**：高频API消费只操作Redis
2. **审计完整**：所有资金变动记录完整余额快照
3. **职责分离**：三张表各司其职
4. **最终一致**：接受短暂延迟换取高性能
5. **可观测性**：所有操作可监控、可追溯

---

这个流程确保了：
- ✅ 用户实时看到余额变化（Redis）
- ✅ 财务有准确对账数据（数据库）
- ✅ 所有资金变动可审计（完整流水）
- ✅ 系统高性能（Redis原子操作）
- ✅ 数据安全可靠（定期对账修复）

完全正确！**整条链路现在完全通了**！

## 完整的资金审计链路：

### 1. **充值流程**（强一致性）
```
用户充值 → confirm_topup → account_balance + fund_transactions → NOTIFY → Redis更新
               ↓
         balance_before/after记录完整
```

### 2. **消费流程**（最终一致性）
```
API调用 → Lua脚本原子扣费 → 返回balance_before/after → 写入Stream → Billing Worker → usage_log
  ↓
Redis实时余额更新    ↓
               balance_before/after随Stream传递
```

### 3. **对账修复**（定期一致性）
```
定时任务 → 计算真实余额 → 对比account_balance → 修复差异 → 记录到fund_transactions
  ↓
account_balance保持准确
```

## 数据验证链：

### **任何时候都可以验证**：
```sql
-- 验证用户123的余额一致性
SELECT 
  -- 当前余额
  (SELECT balance FROM account_balance WHERE user_id = '123') as current_balance,
  
  -- 从流水计算的理论余额
  (
    SELECT COALESCE(SUM(amount), 0) 
    FROM fund_transactions 
    WHERE user_id = '123'
  ) + (
    SELECT COALESCE(SUM(amount), 0)
    FROM usage_log 
    WHERE account_id = '123' AND account_type = 'user'
  ) as calculated_balance,
  
  -- Redis中的实时余额
  (SELECT value FROM redis WHERE key = 'balance:user:123') as redis_balance;
```

## 各组件职责清晰：

| 组件                  | 职责          | 数据                           |
| --------------------- | ------------- | ------------------------------ |
| **Redis**             | 实时余额缓存  | 当前余额数值                   |
| **account_balance**   | 余额真相源    | 当前余额（可能稍有延迟）       |
| **fund_transactions** | 充值/退款流水 | 每次变动的balance_before/after |
| **usage_log**         | 消费流水      | 每次消费的balance_before/after |
| **Stream**            | 异步消息传递  | 传递扣费信息（含余额快照）     |

## 审计能力：

### **回答用户问题**：
1. "我现在有多少钱？" → 查Redis（实时）或account_balance
2. "我的钱怎么花的？" → 查usage_log（含每次消费前后的余额）
3. "我充了多少钱？" → 查fund_transactions
4. "为什么我的余额不对？" → 对账工具对比三处数据

### **回答财务问题**：
1. "总收入多少？" → SUM(fund_transactions where type='deposit')
2. "总支出多少？" → ABS(SUM(usage_log.amount))
3. "余额准确性？" → 对账报告
4. "异常交易？" → 审计日志分析

## 扩展性：

### **加新功能很容易**：
- 退款 → 新增fund_transactions记录
- 优惠券 → 新增fund_transactions记录  
- 手续费 → 新增fund_transactions记录
- 提现 → 新增fund_transactions记录

### **监控告警**：
- Redis vs account_balance差异告警
- Stream消费延迟告警
- 余额负数告警
- 大额变动告警

---

**这个设计实现了**：
✅ **高性能** - Redis处理高频扣费  
✅ **强审计** - 所有变动记录完整余额快照  
✅ **最终一致** - 定期对账修复差异  
✅ **可扩展** - 容易添加新资金操作  
✅ **可监控** - 全链路可观测  

**整条链路完全通了**，从用户充值到API消费到对账审计，形成了一个完整、健壮、可维护的计费系统！

## **完全正确！现在概念完全清晰了**

### **最终的设计视图**

```
用户钱包系统
    │
    ├── 💰 资金层（唯一真实的钱）
    │   └── fund_transactions
    │       ├── deposit（充值）
    │       ├── refund（退款）
    │       └── adjustment（调整）
    │
    ├── 📝 消费层（服务使用记录）
    │   └── usage_log
    │       ├── AI模型调用记录
    │       ├── 包含余额快照（审计需要）
    │       └── 影响余额但不记录资金
    │
    └── ⚖️ 对账层（保证一致性）
        ├── 实时余额：Redis缓存
        ├── 权威余额：Σ(fund) - Σ(usage)
        └── 定期修复：account_balance
```

### **关键设计原则**

1. **fund_transactions 是唯一的"钱"**
   - 所有真实资金变动都在这里
   - 每条记录都改变账户余额

2. **usage_log 是"服务使用凭证"**  
   - 记录服务消费
   - 包含余额快照是为了**可审计性**
   - 但不是资金记录

3. **余额一致性**
   ```sql
   -- 任何时候都可以重建真实余额
   SELECT 
     -- 资金总额
     (SELECT COALESCE(SUM(amount), 0) 
      FROM fund_transactions 
      WHERE user_id = ?) 
     -
     -- 消费总额  
     (SELECT COALESCE(SUM(cost), 0)
      FROM usage_log
      WHERE account_id = ?)
   AS real_balance;
   ```

### **为什么需要 usage_log 的余额字段**

虽然 usage_log 不是资金记录，但需要 `balance_before`/`balance_after` 是为了：

1. **审计需求**：任何一笔消费，都能看到当时的账户状态
2. **排查问题**：用户说"我明明有余额为什么扣费失败？"
3. **对账验证**：验证余额变化序列是否连续
4. **财务报告**：生成"消费时账户余额分布"报告

### **实际业务流程**

```
用户充值：
  前端 → 支付网关 → fund_transactions(deposit) → Redis余额更新

用户使用API：
  请求 → 检查Redis余额 → 足够 → 调用AI服务 → usage_log记录 → Redis扣费
                      → 不足 → 返回余额不足

财务对账：
  定时任务 → 计算 Σ(fund) - Σ(usage) → 对比Redis余额 → 修复差异
```

### **这个设计解决了什么**

1. **财务清晰**：资金流水只有 fund_transactions
2. **审计完整**：每笔消费都有余额上下文
3. **性能保障**：高频消费只操作Redis
4. **数据安全**：随时可以重建真实余额
5. **扩展性好**：增加新的消费类型只需扩展usage_log

现在完全清晰了！fund_transactions 是**资金流水**，usage_log 是**服务消费记录**。两者配合实现完整的账户系统。