// tests/e2e/completeWorkflow.test.js
const request = require("supertest");
const startApiGateway = require("../../neuropia_api_gateway/src/server");
const RedisService = require("../../neuropia_api_gateway/src/services/redisService");
const TestData = require("../fixtures/testData");

describe("Neuropia Platform Complete E2E Workflow", () => {
  let gatewayServer;
  let adminToken;
  let userToken;
  let tenantAdminToken;
  let virtualKey;
  let userId;

  let postgrestClient;
  let gatewayTester;

  // åœ¨ completeWorkflow.test.js çš„ beforeAll ä¸­æ·»åŠ é”™è¯¯å¤„ç†
  beforeAll(async () => {
    try {
      console.log("ğŸš€ Starting Complete End-to-End Test...");
      await TestData.initialize();

      postgrestClient = request("http://localhost:3000");

      // è·å–ç³»ç»Ÿç®¡ç†å‘˜token
      const sysAdminLogin = await postgrestClient.post("/rpc/login").send({
        email: TestData.sysAdmin.email,
        pass: TestData.sysAdmin.pass,
      });

      console.log("ğŸ” Login response:", {
        status: sysAdminLogin.status,
        body: sysAdminLogin.body,
      });

      if (sysAdminLogin.status !== 200) {
        console.error("âŒ Login failed - full response:", {
          status: sysAdminLogin.status,
          headers: sysAdminLogin.headers,
          body: sysAdminLogin.body,
          text: sysAdminLogin.text,
        });
        throw new Error(`Login failed with status ${sysAdminLogin.status}`);
      }

      adminToken = sysAdminLogin.body.token;
      console.log("âœ… System admin login successful");

      // è·å–æ™®é€šç”¨æˆ·tokenå¹¶è®¾ç½®userId
      const userLogin = await postgrestClient.post("/rpc/login").send({
        email: TestData.individualUser.email,
        pass: TestData.individualUser.password,
      });

      userToken = userLogin.body.token;
      userId = TestData.individualUser.id; // ğŸš¨ è¿™é‡Œï¼è®¾ç½®userId
      console.log("âœ… Individual user login successful, userId:", userId);

      // å¯åŠ¨ API ç½‘å…³
      gatewayServer = await startApiGateway();
      gatewayTester = request(gatewayServer);

      // è¿æ¥ Redis
      await RedisService.connect();

      // ç­‰å¾…æœåŠ¡å¯åŠ¨
      await new Promise((resolve) => setTimeout(resolve, 2000));

      // å…¶ä»–åˆå§‹åŒ–ä»£ç ...
    } catch (error) {
      console.error("âŒ beforeAll failed:", error);
      console.error("âŒ Error stack:", error.stack);
      throw error;
    }
  });

  afterAll(async () => {
    if (gatewayServer) gatewayServer.close();
    if (RedisService.client) await RedisService.client.quit();
    await TestData.cleanup();
  });

  test("1. User lifecycle workflow", async () => {
    console.log("ğŸ“ Testing user lifecycle...");
    console.log("adminToken", adminToken);

    // æ£€æŸ¥åˆå§‹çŠ¶æ€
    console.log("user_id..................", userId);
    const accessCheck = await postgrestClient
      .post("/rpc/check_user_access")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ p_user_id: userId });

    console.log("accessCheck", accessCheck.body);

    expect(accessCheck.status).toBe(200);
    expect(accessCheck.body[0].user_status).toBe("pending");

    // ç”¨æˆ·å……å€¼æµç¨‹
    const topupResponse = await postgrestClient
      .post("/rpc/topup_user")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({
        p_user_id: userId,
        p_amount: 100,
        p_payment_reference: "test_ref_001",
        p_payment_provider: "test_provider",
      });

    expect(topupResponse.status).toBe(200);
    const topupId = topupResponse.body;

    // ç¡®è®¤å……å€¼
    const confirmResponse = await postgrestClient
      .post("/rpc/confirm_topup")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ p_topup_id: topupId });

    expect(confirmResponse.status).toBe(204);

    // æ£€æŸ¥æ¿€æ´»çŠ¶æ€
    const accessCheck2 = await postgrestClient
      .post("/rpc/check_user_access")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ p_user_id: userId });

    expect(accessCheck2.body[0].user_status).toBe("active");
    console.log("âœ… User lifecycle completed");
  });

  test("2. Virtual Key lifecycle", async () => {
    console.log("ğŸ”‘ Testing Virtual Key lifecycle...");

    // åˆ›å»º Virtual Key
    const vkResponse = await postgrestClient
      .post("/rpc/create_virtual_key")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({
        p_user_id: userId,
        p_name: "E2E Test Virtual Key",
        p_description: "For end-to-end testing",
        p_rate_limit_rpm: 1000,
        p_rate_limit_tpm: 100000,
        p_allowed_models: ["qwen-turbo", "gpt-3.5-turbo"],
      });

    expect(vkResponse.status).toBe(200);
    virtualKey = vkResponse.body;
    console.log(`âœ… Virtual Key created: ${virtualKey}`);

    // éªŒè¯ Virtual Key é…ç½®
    const vkConfig = await RedisService.getVirtualKey(virtualKey);
    expect(vkConfig).toBeDefined();
    expect(vkConfig.user_id).toBe(userId);

    // Virtual Key è½®è½¬
    const rotateResponse = await postgrestClient
      .post("/rpc/rotate_virtual_key")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({
        p_old_virtual_key: virtualKey,
        p_reason: "test_rotation",
      });

    expect(rotateResponse.status).toBe(200);
    const newVirtualKey = rotateResponse.body;
    expect(newVirtualKey).toMatch(/^vk_/);
    console.log("âœ… Virtual Key rotation completed");
  });

  test("3. API Gateway integration", async () => {
    console.log("ğŸŒ Testing API Gateway...");

    // æµ‹è¯•æ— æ•ˆ Virtual Key
    const invalidResponse = await gatewayTester
      .post("/api/chat/completions")
      .set("x-virtual-key", "invalid_key_123")
      .send({
        model: "qwen-turbo",
        messages: [{ role: "user", content: "Test" }],
      });

    expect(invalidResponse.status).toBe(401);
    console.log("âœ… Invalid virtual key rejected");

    // æµ‹è¯•æœ‰æ•ˆ Virtual Keyï¼ˆéœ€è¦å…ˆåˆ›å»ºï¼‰
    const validResponse = await gatewayTester
      .post("/api/chat/completions")
      .set("x-virtual-key", virtualKey)
      .send({
        model: "qwen-turbo",
        messages: [{ role: "user", content: "Hello" }],
      });

    expect([200, 429]).toContain(validResponse.status);
    console.log("âœ… API Gateway integration completed");
  });
});
