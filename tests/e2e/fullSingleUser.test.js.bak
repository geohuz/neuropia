// tests/e2e/fullSingleUser.test.js
const request = require("supertest");
const startApiGateway = require("../../neuropia_api_gateway/src/server");
const RedisService = require("../../neuropia_api_gateway/src/services/redisService");

describe("Neuropia Platform Complete E2E Workflow", () => {
  let gatewayServer;
  let adminToken;
  let userToken;
  let virtualKey;
  let userId;

  let postgrestClient;
  let gatewayTester;

  beforeAll(async () => {
    try {
      console.log("ğŸš€ Starting Complete End-to-End Test...");

      // å¯åŠ¨ API ç½‘å…³
      gatewayServer = await startApiGateway();
      gatewayTester = request(gatewayServer);

      // è¿æ¥ Redis
      await RedisService.connect();

      postgrestClient = request("http://localhost:3000");

      // 1. ç®¡ç†å‘˜ç™»å½•
      const adminLogin = await postgrestClient.post("/rpc/login").send({
        email: "api@neuropia",
        pass: "api",
      });

      console.log("ğŸ” Admin login:", {
        status: adminLogin.status,
        body: adminLogin.body,
      });

      adminToken = adminLogin.body.token;
      console.log("âœ… System admin login successful");

      // 2. æ³¨å†Œæ–°ç”¨æˆ·ï¼ˆç‹¬ç«‹ç”¨æˆ·ï¼‰
      const registerResponse = await postgrestClient
        .post("/rpc/register_user")
        .set("Authorization", `Bearer ${adminToken}`)
        .send({
          p_email: "e2e-test-user@neuropia.com",
          p_username: "e2etestuser",
          p_password: "testpass123",
          p_role: "norm_user",
          p_tenant_id: null,
        });

      console.log("ğŸ” User registration:", {
        status: registerResponse.status,
        body: registerResponse.body,
      });

      userId = registerResponse.body;
      console.log("âœ… User registered, ID:", userId);

      // 3. ç”¨æˆ·ç™»å½•
      const userLogin = await postgrestClient.post("/rpc/login").send({
        email: "e2e-test-user@neuropia.com",
        pass: "testpass123",
      });

      userToken = userLogin.body.token;
      console.log("âœ… User login successful");

      // ç­‰å¾…æœåŠ¡å¯åŠ¨
      await new Promise((resolve) => setTimeout(resolve, 2000));
    } catch (error) {
      console.error("âŒ beforeAll failed:", error);
      throw error;
    }
  });

  afterAll(async () => {
    if (gatewayServer) gatewayServer.close();
    if (RedisService.client) await RedisService.client.quit();
  });

  test("Complete user lifecycle and AI call workflow", async () => {
    console.log("ğŸ“ Testing complete workflow...");

    // 4. æ£€æŸ¥ç”¨æˆ·è®¿é—®æƒé™ï¼ˆä½¿ç”¨ç®¡ç†å‘˜tokenï¼‰
    const accessCheck = await postgrestClient
      .post("/rpc/check_user_access")
      .set("Authorization", `Bearer ${adminToken}`) // ä½¿ç”¨ adminToken è€Œä¸æ˜¯ userToken
      .send({ p_user_id: userId });

    console.log("ğŸ” Initial access check:", {
      status: accessCheck.status,
      body: accessCheck.body,
    });

    expect(accessCheck.status).toBe(200);
    expect(accessCheck.body[0].user_status).toBe("pending");
    expect(accessCheck.body[0].can_use_api).toBe(false);
    console.log("âœ… Initial pending status verified");

    // 5. ç”¨æˆ·å……å€¼ï¼ˆä½¿ç”¨ç®¡ç†å‘˜tokenï¼‰
    const topupResponse = await postgrestClient
      .post("/rpc/topup_user")
      .set("Authorization", `Bearer ${adminToken}`) // ä½¿ç”¨ adminToken
      .send({
        p_user_id: userId,
        p_amount: 100,
        p_payment_reference: "test_ref_001",
        p_payment_provider: "test_provider",
      });

    console.log("ğŸ” Topup response:", {
      status: topupResponse.status,
      body: topupResponse.body,
    });

    expect(topupResponse.status).toBe(200);
    const topupId = topupResponse.body;
    console.log(`âœ… Topup created: ${topupId}`);

    // 6. ç¡®è®¤å……å€¼
    const confirmResponse = await postgrestClient
      .post("/rpc/confirm_topup")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ p_topup_id: topupId });

    expect(confirmResponse.status).toBe(204);
    console.log("âœ… Topup confirmed");

    // 7. å†æ¬¡æ£€æŸ¥ç”¨æˆ·çŠ¶æ€ï¼ˆåº”è¯¥æ˜¯ activeï¼‰
    const accessCheck2 = await postgrestClient
      .post("/rpc/check_user_access")
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ p_user_id: userId });

    console.log("ğŸ” Activated access check:", accessCheck2.body);
    expect(accessCheck2.status).toBe(200);
    expect(accessCheck2.body[0].user_status).toBe("active");
    expect(accessCheck2.body[0].can_use_api).toBe(true);
    console.log("âœ… User activated");

    // 8. åˆ›å»ºè™šæ‹Ÿå¯†é’¥ï¼ˆä½¿ç”¨ç”¨æˆ·è‡ªå·±çš„tokenï¼‰
    const vkResponse = await postgrestClient
      .post("/rpc/create_virtual_key")
      .set("Authorization", `Bearer ${userToken}`) // ä½¿ç”¨ userToken
      .send({
        p_user_id: userId,
        p_name: "E2E Test Virtual Key",
        p_description: "For end-to-end testing",
        p_rate_limit_rpm: 1000,
        p_rate_limit_tpm: 100000,
        p_allowed_models: ["qwen-turbo", "gpt-3.5-turbo"],
      });

    console.log("ğŸ” Virtual Key creation:", {
      status: vkResponse.status,
      body: vkResponse.body,
    });

    expect(vkResponse.status).toBe(200);
    virtualKey = vkResponse.body;
    console.log(`âœ… Virtual Key created: ${virtualKey}`);

    // 9. éªŒè¯ Virtual Key é…ç½®ç¼“å­˜
    const vkConfig = await RedisService.getVirtualKey(virtualKey);
    console.log("ğŸ” Virtual Key config from Redis:", vkConfig);
    expect(vkConfig).toBeDefined();
    expect(vkConfig.user_id).toBe(userId);
    console.log("âœ… Virtual Key cached in Redis");

    // 10. é€šè¿‡ä¸šåŠ¡ç½‘å…³è°ƒç”¨ AI æœåŠ¡
    const aiResponse = await gatewayTester
      .post("/api/chat/completions")
      .set("x-virtual-key", virtualKey)
      .send({
        model: "qwen-turbo",
        messages: [{ role: "user", content: "Hello, world!" }],
        max_tokens: 100,
      });

    console.log("ğŸ” AI API response:", {
      status: aiResponse.status,
      body: aiResponse.body,
    });

    expect([200, 429]).toContain(aiResponse.status); // 200æˆåŠŸæˆ–429é™æµ
    console.log("âœ… AI API call completed");

    console.log("ğŸ‰ Complete workflow test finished!");
  }, 30000);

  test("Virtual key validation and rate limiting", async () => {
    console.log("ğŸ§ª Testing error scenarios...");

    // ç¡®ä¿ virtualKey å·²å®šä¹‰
    if (!virtualKey) {
      console.log("âš ï¸ virtualKey not defined, skipping test");
      return;
    }

    // æµ‹è¯•æ— æ•ˆè™šæ‹Ÿå¯†é’¥
    const invalidResponse = await gatewayTester
      .post("/api/chat/completions")
      .set("x-virtual-key", "invalid_key_123")
      .send({
        model: "qwen-turbo",
        messages: [{ role: "user", content: "Test" }],
      });

    expect(invalidResponse.status).toBe(401);
    console.log("âœ… Invalid virtual key rejected");

    // æµ‹è¯•æ¨¡å‹æƒé™
    const wrongModelResponse = await gatewayTester
      .post("/api/chat/completions")
      .set("x-virtual-key", virtualKey)
      .send({
        model: "claude-2", // ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­
        messages: [{ role: "user", content: "Test" }],
      });

    expect(wrongModelResponse.status).toBe(403);
    console.log("âœ… Model restriction enforced");
  });
});
