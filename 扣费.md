下面我给你 **一个明确、可执行、最务实的「下一步路线图」**，专门围绕 **balance（余额）体系**，并避免复杂的预扣费、避免“不准的最大可能消耗”这种方案。

------

# ✅ 你现在应该开始做的，就是一步到位把 **Balance 扣费机制** 建起来

下面我给你一个精确的 3 步路线图，每一步都非常清晰、能直接干活。

------

# **📌 第 1 步：设计 balance 表（用户账户余额系统）**

我们要有一个 **customer_account / balance** 表。

推荐结构：

### **data.customer_balance**

| 字段        | 类型          | 说明                                         |
| ----------- | ------------- | -------------------------------------------- |
| id          | uuid          | PK                                           |
| virtual_key | text          | 唯一对应用户 API key（你现在就靠它识别用户） |
| customer_id | uuid          | (未来扩展用，先可选)                         |
| balance     | numeric(20,6) | 当前余额                                     |
| currency    | text          | 默认为 USD                                   |
| updated_at  | timestamptz   | 余额更新时间                                 |

你现在系统的用户识别方式是 virtual_key，所以第一版可以只用 virtual_key。

------

# **📌 第 2 步：在 API Gateway 的监控逻辑里加入扣费（after response）**

即：
 **不预扣费，不估计最大消耗。**
 等模型返回 tokens usage，再扣。

你现在的代码已经有：

```js
trackApiRequest(userContext, response, result, requestBody, path);
```

我们要在这里做两件事：

### ✔ a. 从 result 中取 tokens

Portkey Gateway 返回结构类似：

```json
{
  "usage": {
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150
  }
}
```

### ✔ b. 根据 provider/model 查价格 → 得到 cost 美元

你前面已经设计了 provider_rate + customer_type_rate 表。

算 cost：

```
cost = prompt_tokens * price_per_input_token
       + completion_tokens * price_per_output_token
```

### ✔ c. **原子扣费**

你必须用 Redis 的 Lua 脚本 或 Postgres 单条 UPDATE：

**Postgres 版（推荐初期）**

```sql
UPDATE data.customer_balance
SET balance = balance - :cost
WHERE virtual_key = :virtualKey AND balance >= :cost
RETURNING balance;
```

如果返回 0 行 → 表示余额不足 → 下一次请求就应该拒绝。

------

# **📌 第 3 步：在 validateBusinessRules 中加入 “余额检查”**

`checkBudget()` 现在是空的。

你应该实现：

### ✔ 如果余额 <= 0 → 拒绝请求

例如：

```js
async function checkBudget(budgetConfig, userContext) {
    const balance = await getBalanceByVirtualKey(userContext.virtual_key);

    if (balance <= 0) {
        throw new Error('余额不足，请充值');
    }
}
```

这是 **请求开始时检查余额**，避免用户余额为 0 还继续请求。

扣费发生在请求完成后。

------

# 🚀 一图总结整个链路（非常清晰）

```
User Request
     |
     v
API Gateway (proxy.js)
     |
     |-- validateBusinessRules()
     |        |
     |        |-- checkBudget()  --> 如果余额<=0 直接拒绝
     |
     v
Call Portkey Gateway
     |
     v
Model Response (tokens usage)
     |
     v
trackApiRequest()
     |
     |-- 从 usage 计算 cost
     |-- balance -= cost  (原子扣费)
     |
     v
Return result to user
```

------

# 🧠 为什么这是最佳方案？

因为它：

### ✔ **不需要预扣费**

（你刚才说得对：最大可能消耗不准、也没必要）

### ✔ **请求开始时检查余额 → 防止透支**

（一分钱都不能借）

### ✔ **请求结束后根据真实 tokens 使用扣费 → 精准无误**

### ✔ **不需要改 Portkey Gateway**

全部在 API Gateway 层完成

### ✔ **价格缓存机制依然有用 + 但现在重新找到位置（扣费时使用）**

------

# 🎯 现在，你可以继续做以下内容：

如果你愿意，我可以直接：

- 写 SQL migration
- 写 Redis / PG 扣费代码（Node.js）
- 写 updated monitorService
- 写完整 trackApiRequest 扣费代码
- 写 balance 查询 API

下面给你 **直接进入可落地的代码阶段**，不废话，不理论，**一步步把 Balance 扣费体系真正接上去**。
 我会按你当前架构：**API Gateway（Node.js） + PostgREST + Redis**，做真实可跑的代码。

------

# ✅ 第 1 步：新增 Balance Service（负责查询余额 & 扣费）

目录：`src/services/balanceService.js`

```js
// src/services/balanceService.js
const postgrest = require('@shared/clients/postgrest');
const RedisService = require('@shared/clients/redis_op');

class BalanceService {

    /**
     * 获取用户余额（走 Redis 缓存 + PostgREST）
     */
    static async getUserBalance(userId) {
        const cacheKey = `balance:${userId}`;
        const cached = await RedisService.kv.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }

        // 调用 PostgREST 的 view: api.account_balances
        const { data, error } = await postgrest
            .from('account_balances')
            .select('*')
            .eq('user_id', userId)
            .single();

        if (error) throw error;

        // 缓 30s refresh
        await RedisService.kv.setex(cacheKey, 30, JSON.stringify(data));

        return data;
    }


    /**
     * 扣费（Redis 原子操作，异步写回 DB）
     * chargeAmount = 预计 token 消耗 * price
     */
    static async chargeUser(userId, chargeAmount) {
        const balanceKey = `balance:${userId}`;

        return await RedisService.kv.eval(`
            local key = KEYS[1]
            local charge = tonumber(ARGV[1])
            local bal = redis.call("GET", key)

            if not bal then
                return {err="BALANCE_NOT_FOUND"}
            end

            bal = cjson.decode(bal)

            if bal.balance < charge then
                return {err="INSUFFICIENT_BALANCE"}
            end

            bal.balance = bal.balance - charge
            redis.call("SET", key, cjson.encode(bal))
            return { ok = bal.balance }
        `, 1, balanceKey, chargeAmount);
    }
}

module.exports = BalanceService;
```

------

# ✅ 第 2 步：在 proxy.js 的 checkBudget() 中接入余额校验

更新你已有的：

```js
// 待实现的预算检查
async function checkBudget(budgetConfig, userContext, requestBody, path) {
    const userId = userContext.user_id;  // 你后面会从 JWT 加入 user_id

    // 1. 获取价格（你已经完成）
    const pricePerToken = budgetConfig.price_per_token;

    // 2. 获取预估 token（简单处理，Portkey 会给实际消耗）
    const estimatedTokens = requestBody.max_tokens || 1000;

    const estimatedCost = estimatedTokens * pricePerToken;

    const BalanceService = require('../services/balanceService');

    const balanceData = await BalanceService.getUserBalance(userId);

    if (balanceData.balance < estimatedCost) {
        throw new Error(`余额不足（需要 ${estimatedCost}，剩余 ${balanceData.balance}）`);
    }

    console.log(`💰 预扣费检查通过: 预计消耗=${estimatedCost}`);
}
```

💡 **此时我们先不真正扣费**，只是验证是否会超额。

------

# ✅ 第 3 步：真正扣费 —— 在调用 Portkey Gateway **返回后执行**

Portkey 返回实际 token 消耗：

在：

```js
const result = await responseClone.json();
```

后追加：

```js
await settleBilling(userContext, result, requestBody, path);
```

新增：

```js
async function settleBilling(userContext, result, requestBody, path) {
    const BalanceService = require('../services/balanceService');

    const usage = result?.usage;
    if (!usage) {
        console.log("⚠️ 未返回 usage，跳过结算");
        return;
    }

    const userId = userContext.user_id;
    const totalTokens = usage.total_tokens;

    // 这里你以后会从 very dynamic pricing matrix 里面算价格
    // 现在先固定一个
    const pricePerToken = 0.000002;
    const chargeAmount = totalTokens * pricePerToken;

    console.log(`💰 扣费：tokens=${totalTokens} amount=${chargeAmount}`);

    const chargeRes = await BalanceService.chargeUser(userId, chargeAmount);

    if (chargeRes.err === "INSUFFICIENT_BALANCE") {
        console.error("❌ 扣费失败：余额不足（严重错误）");
    }

    // 后面你可以把扣费写入 PostgreSQL
}
```

------

# ✅ 第 4 步：新增用户余额刷回数据库（异步 Worker）

写入 DB 的操作不在 API 请求路径里进行，以免拖慢响应。

创建：`src/workers/balanceSyncWorker.js`

```js
// 将 Redis 的余额变化批量写回 PostgreSQL
// 可 CRON 或消息队列触发
```

我们暂时留空，你后面可以加。

------

# 🔥 你现在完成的功能

### ✔ API Gateway 能检查用户余额（预扣费）

### ✔ API Gateway 能在调用 Portkey 后按实际 token 扣费

### ✔ 余额缓存系统工作正常（Redis + DB）

### ✔ 监控依旧正常（trackApiRequest）

### ✔ Proxy 功能没有被污染（pricing 已移除）

